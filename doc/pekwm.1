.\" Automatically generated by Pod::Man v1.37, Pod::Parser v1.3
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sh \" Subsection heading
.br
.if t .Sp
.ne 5
.PP
\fB\\$1\fR
.PP
..
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  | will give a
.\" real vertical bar.  \*(C+ will give a nicer C++.  Capital omega is used to
.\" do unbreakable dashes and therefore won't be available.  \*(C` and \*(C'
.\" expand to `' in nroff, nothing in troff, for use with C<>.
.tr \(*W-|\(bv\*(Tr
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
'br\}
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.Sh), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.if \nF \{\
.    de IX
.    tm Index:\\$1\t\\n%\t"\\$2"
..
.    nr % 0
.    rr F
.\}
.\"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.hy 0
.if n .na
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "PEKWM 1"
.TH PEKWM 1 "2006-02-22" "perl v5.8.7" "PEKWM Documentation"
.SH "Pekwm Documentation"
.IX Header "Pekwm Documentation"
.Sh "Documentation corresponding to pekwm\-0.1.4, last updated February 22, 2006."
.IX Subsection "Documentation corresponding to pekwm-0.1.4, last updated February 22, 2006."
.Sh "Rando Christensen"
.IX Subsection "Rando Christensen"
.Sh "Jyri Jokinen"
.IX Subsection "Jyri Jokinen"
Copyright E<copy> 2002\-2006 by the pekwm development team
.PP
This document aims to be a complete documentation of the pekwm window
manager.
.PP
Copyright (c) 2002\-2006 the pekwm development team
.PP
All rights reserved.
.PP
\&\-\-\-\-
.IP "Table of Contents" 4
.IX Item "Table of Contents"
.PD 0
.IP "I. An overview of pekwm" 4
.IX Item "I. An overview of pekwm"
.RS 4
.IP "1. An Introduction to Pekwm" 4
.IX Item "1. An Introduction to Pekwm"
.RS 4
.IP "1.1. Why Pekwm?" 4
.IX Item "1.1. Why Pekwm?"
.IP "1.2. Pekwm Features" 4
.IX Item "1.2. Pekwm Features"
.RE
.RS 4
.RE
.IP "2. Getting Pekwm" 4
.IX Item "2. Getting Pekwm"
.RS 4
.IP "2.1. Getting the Pekwm source" 4
.IX Item "2.1. Getting the Pekwm source"
.IP "2.2. Getting prebuilt Pekwm packages" 4
.IX Item "2.2. Getting prebuilt Pekwm packages"
.RE
.RS 4
.RE
.IP "3. Compiling Pekwm" 4
.IX Item "3. Compiling Pekwm"
.RS 4
.IP "3.1. Unpacking the Archive" 4
.IX Item "3.1. Unpacking the Archive"
.IP "3.2. Configuration Options" 4
.IX Item "3.2. Configuration Options"
.IP "3.3. Building and installing" 4
.IX Item "3.3. Building and installing"
.RE
.RS 4
.RE
.RE
.RS 4
.RE
.IP "\s-1II\s0. Basic Usage" 4
.IX Item "II. Basic Usage"
.RS 4
.IP "4. Getting Started" 4
.IX Item "4. Getting Started"
.RS 4
.IP "4.1. First Run" 4
.IX Item "4.1. First Run"
.IP "4.2. About Menus and Iconification" 4
.IX Item "4.2. About Menus and Iconification"
.IP "4.3. Using the mouse" 4
.IX Item "4.3. Using the mouse"
.IP "4.4. Using the keyboard" 4
.IX Item "4.4. Using the keyboard"
.RE
.RS 4
.RE
.IP "5. Window Grouping" 4
.IX Item "5. Window Grouping"
.RS 4
.IP "5.1. What is window grouping?" 4
.IX Item "5.1. What is window grouping?"
.IP "5.2. How window grouping works" 4
.IX Item "5.2. How window grouping works"
.IP "5.3. Advanced Grouping Topics" 4
.IX Item "5.3. Advanced Grouping Topics"
.RE
.RS 4
.RE
.IP "6. Workspaces" 4
.IX Item "6. Workspaces"
.RS 4
.IP "6.1. Workspace Navigation" 4
.IX Item "6.1. Workspace Navigation"
.IP "6.2. Viewports" 4
.IX Item "6.2. Viewports"
.RE
.RS 4
.RE
.RE
.RS 4
.RE
.IP "\s-1III\s0. Configuration" 4
.IX Item "III. Configuration"
.RS 4
.IP "7. The Pekwm Common Syntax for Config Files" 4
.IX Item "7. The Pekwm Common Syntax for Config Files"
.RS 4
.IP "7.1. Basic Syntax" 4
.IX Item "7.1. Basic Syntax"
.IP "7.2. Variables In Pekwm Config Files" 4
.IX Item "7.2. Variables In Pekwm Config Files"
.RE
.RS 4
.RE
.IP "8. The main config file" 4
.IX Item "8. The main config file"
.RS 4
.IP "8.1. Basic Config" 4
.IX Item "8.1. Basic Config"
.IP "8.2. Config File Keywords" 4
.IX Item "8.2. Config File Keywords"
.IP "8.3. Screen Subsections" 4
.IX Item "8.3. Screen Subsections"
.RE
.RS 4
.RE
.IP "9. Configuring the menus" 4
.IX Item "9. Configuring the menus"
.RS 4
.IP "9.1. Basic Menu Syntax" 4
.IX Item "9.1. Basic Menu Syntax"
.IP "9.2. Menu Keywords" 4
.IX Item "9.2. Menu Keywords"
.IP "9.3. Dynamic Menus" 4
.IX Item "9.3. Dynamic Menus"
.RE
.RS 4
.RE
.IP "10. Autoproperties" 4
.IX Item "10. Autoproperties"
.RS 4
.IP "10.1. What are Autoproperties?" 4
.IX Item "10.1. What are Autoproperties?"
.IP "10.2. Basic Autoproperties Syntax" 4
.IX Item "10.2. Basic Autoproperties Syntax"
.IP "10.3. Advanced Autoproperties" 4
.IX Item "10.3. Advanced Autoproperties"
.IP "10.4. AutoGrouping" 4
.IX Item "10.4. AutoGrouping"
.IP "10.5. Getting more help" 4
.IX Item "10.5. Getting more help"
.RE
.RS 4
.RE
.IP "11. Keyboard and Mouse Configuration" 4
.IX Item "11. Keyboard and Mouse Configuration"
.RS 4
.IP "11.1. Mouse Bindings" 4
.IX Item "11.1. Mouse Bindings"
.IP "11.2. Border Subsection" 4
.IX Item "11.2. Border Subsection"
.IP "11.3. ScreenEdge Subsection" 4
.IX Item "11.3. ScreenEdge Subsection"
.IP "11.4. Key Bindings" 4
.IX Item "11.4. Key Bindings"
.IP "11.5. Keychains" 4
.IX Item "11.5. Keychains"
.IP "11.6. Keys/Mouse actions and window attributes" 4
.IX Item "11.6. Keys/Mouse actions and window attributes"
.RE
.RS 4
.RE
.IP "12. The pekwm start file" 4
.IX Item "12. The pekwm start file"
.IP "13. Pekwm themes" 4
.IX Item "13. Pekwm themes"
.RS 4
.IP "13.1. Guidelines" 4
.IX Item "13.1. Guidelines"
.IP "13.2. Attribute names used, explanations, possible values, examples" 4
.IX Item "13.2. Attribute names used, explanations, possible values, examples"
.IP "13.3. Structure" 4
.IX Item "13.3. Structure"
.RE
.RS 4
.RE
.RE
.RS 4
.RE
.IP "\s-1IV\s0. Development" 4
.IX Item "IV. Development"
.RS 4
.IP "14. Mailing Lists" 4
.IX Item "14. Mailing Lists"
.RS 4
.IP "14.1. The Lists" 4
.IX Item "14.1. The Lists"
.IP "14.2. Mailing list Archives" 4
.IX Item "14.2. Mailing list Archives"
.IP "14.3. Subscribing and Filtering" 4
.IX Item "14.3. Subscribing and Filtering"
.RE
.RS 4
.RE
.IP "15. \s-1IRC\s0" 4
.IX Item "15. IRC"
.IP "16. Bug Tracker" 4
.IX Item "16. Bug Tracker"
.IP "17. The developers" 4
.IX Item "17. The developers"
.RE
.RS 4
.RE
.IP "V. The pekwm \s-1FAQ\s0" 4
.IX Item "V. The pekwm FAQ"
.RS 4
.IP "18. Common questions and answers" 4
.IX Item "18. Common questions and answers"
.RS 4
.IP "18.1. How is this ~/.pekwm/start thing used?" 4
.IX Item "18.1. How is this ~/.pekwm/start thing used?"
.IP "18.2. What is the harbour?" 4
.IX Item "18.2. What is the harbour?"
.IP "18.3. Why doesn't the harbour work for my dockapp?" 4
.IX Item "18.3. Why doesn't the harbour work for my dockapp?"
.IP "18.4. Can I have automatically changing menus in pekwm?" 4
.IX Item "18.4. Can I have automatically changing menus in pekwm?"
.IP "18.5. How do I install themes?" 4
.IX Item "18.5. How do I install themes?"
.IP "18.6. I upgraded pekwm and now ......... won't work!" 4
.IX Item "18.6. I upgraded pekwm and now ......... won't work!"
.IP "18.7. Can I turn off this sloppy focus crap?" 4
.IX Item "18.7. Can I turn off this sloppy focus crap?"
.IP "18.8. What is Mod1? How about Mod4?" 4
.IX Item "18.8. What is Mod1? How about Mod4?"
.IP "18.9. Why do my terminals start the wrong size when grouped?" 4
.IX Item "18.9. Why do my terminals start the wrong size when grouped?"
.IP "18.10. Where can I find the current size/position of a window?" 4
.IX Item "18.10. Where can I find the current size/position of a window?"
.IP "18.11. How do I bring up the window menu when the window has no decorations?" 4
.IX Item "18.11. How do I bring up the window menu when the window has no decorations?"
.IP "18.12. When I xprop a grouped window, it gives the results of wrong window!" 4
.IX Item "18.12. When I xprop a grouped window, it gives the results of wrong window!"
.IP "18.13. The start file doesn't work!" 4
.IX Item "18.13. The start file doesn't work!"
.IP "18.14. How do I set a background/root/desktop image?" 4
.IX Item "18.14. How do I set a background/root/desktop image?"
.IP "18.15. A theme I tested doesn't work!" 4
.IX Item "18.15. A theme I tested doesn't work!"
.IP "18.16. PekWM just dumps core, FreeBSD." 4
.IX Item "18.16. PekWM just dumps core, FreeBSD."
.IP "18.17. What desktop pagers work with pekwm?" 4
.IX Item "18.17. What desktop pagers work with pekwm?"
.IP "18.18. How do I make submenus open on mouse over rather than when clicked?" 4
.IX Item "18.18. How do I make submenus open on mouse over rather than when clicked?"
.RE
.RS 4
.RE
.RE
.RS 4
.RE
.PD
.SH "I. An overview of pekwm"
.IX Header "I. An overview of pekwm"
Pekwm is a fast, functional, and flexible window manager which aims to
be useable, even without a mouse.
.IP "Table of Contents" 4
.IX Item "Table of Contents"
.PD 0
.IP "1. An Introduction to Pekwm" 4
.IX Item "1. An Introduction to Pekwm"
.IP "2. Getting Pekwm" 4
.IX Item "2. Getting Pekwm"
.IP "3. Compiling Pekwm" 4
.IX Item "3. Compiling Pekwm"
.PD
.PP
\&\-\-\-\-
.SH "Chapter 1. An Introduction to Pekwm"
.IX Header "Chapter 1. An Introduction to Pekwm"
The Pekwm Window Manager is written by Claes Na\*:sten. The code is
based on the aewm++ window manager, but it has evolved enough that it
no longer resembles aewm++ at all. It also has an expanded feature\-set,
including window grouping (similar to ion, pwm, or fluxbox), auto
properties, xinerama and keygrabber that supports keychains, and much
more.
.PP
\&\-\-\-\-
.Sh "1.1. Why Pekwm?"
.IX Subsection "1.1. Why Pekwm?"
\&\*(L"Why make another window manager?\*(R", some ask. This may confuse some
people, but the best answer is \*(L"Why not?\*(R". There are arguments out
there that it's better to have a single standard desktop environment,
so that our mothers can find their way around, but in all honestly, if
most of us wanted the same environment as our mothers, we probably
wouldn't be reading this anyway. The same can also be applied to Your
sister, your roommate, your wife, even your cat.
.PP
\&\*(L"Why should I use pekwm?\*(R", others ask. Nobody ever said you should.
However, we use it. And you're welcome to as well. You should use the
environment most suited to you. For a better answer to this question,
Check out the Pekwm Features section below.
.PP
\&\-\-\-\-
.Sh "1.2. Pekwm Features"
.IX Subsection "1.2. Pekwm Features"
Here's a short list of some of the features included in pekwm:
.IP "\(bu" 4
Possibility to group windows in a single frame
.IP "\(bu" 4
Configurable keygrabber that supports keychains
.IP "\(bu" 4
Configurable mouse actions
.IP "\(bu" 4
Configurable rootmenu and windowmenu
.IP "\(bu" 4
Xinerama support
.IP "\(bu" 4
Configurable window placement
.IP "\(bu" 4
Basic pixmap theming, with configurable buttons
.IP "\(bu" 4
Autoproperties (Automatic properties such as a window's sticky state,
etc.)
.IP "\(bu" 4
Dynamic menus (menus that regenerate on every view)
.IP "\(bu" 4
Xft font support (anti\-aliased fonts)
.IP "\(bu" 4
Imlib2 image handling support
.PP
\&\-\-\-\-
.SH "Chapter 2. Getting Pekwm"
.IX Header "Chapter 2. Getting Pekwm"
Now that you've decided to try it out, you need to get it. You're left
with two options. The first is to download and compile the source, and
the second is finding a pre-compiled package.
.PP
\&\-\-\-\-
.Sh "2.1. Getting the Pekwm source"
.IX Subsection "2.1. Getting the Pekwm source"
The source code is available from the pekwm website, http://pekwm.org.
.PP
Files are named pekwm\-0.1.4.tar.gz and pekwm\-0.1.4.tar.bz2. Although it
doesn't matter which you get, keep in mind that the .bz2 is smaller.
.PP
\&\-\-\-\-
.Sh "2.2. Getting prebuilt Pekwm packages"
.IX Subsection "2.2. Getting prebuilt Pekwm packages"
Links to pre-built pekwm packages are available at the pekwm website,
http://pekwm.org.
.PP
The current version of pekwm is 0.1.4.
.PP
If there's no package for your distribution, and you'd like to build
one, Let us know! We'll gladly host or link to binary packages.
.PP
\&\-\-\-\-
.SH "Chapter 3. Compiling Pekwm"
.IX Header "Chapter 3. Compiling Pekwm"
This chapter will help you get pekwm compiled.
.PP
\&\-\-\-\-
.Sh "3.1. Unpacking the Archive"
.IX Subsection "3.1. Unpacking the Archive"
The first step to compiling pekwm is to unpack the archive. Unpacking
it depends on which version you downloaded:
.PP
.Vb 2
\& tar -zxvf pekwm-0.1.4.tar.gz
\& tar -jxvf pekwm-0.1.4.tar.bz2
.Ve
.Sp
.RS 4
The '\-j' option works normally on most linux systems, and as of the
current \s-1GNU\s0 tar development version, is part of \s-1GNU\s0 tar. If your system
does not support the \-j option, you can use two things: \fBbzip2 \-dc
pekwm\-0.1.4.tar.bz2 | tar \-xvf \-\fR or \fBbzip2 \-d pekwm\-0.1.4.tar.bz2\fR
followed by \fBtar \-xvf pekwm\-0.1.4.tar\fR. This also works for the
\&.tar.gz version using \fBgzip \-dc\fR or \fBgzip \-d\fR.
.RE
.PP
The 'v' options are optional, they show you the filenames as they're
being extracted. at this point, you should have a pekwm\-0.1.4
directory. Use \fBcd pekwm\-0.1.4\fR to get there.
.PP
\&\-\-\-\-
.Sh "3.2. Configuration Options"
.IX Subsection "3.2. Configuration Options"
The first thing to do is to run the configure script. This configures
compile options for pekwm. Here are some of the more used options and
what their default values are.
.PP
Important ./configure options:
.IP "\-\-enable\-shape" 4
.IX Item "--enable-shape"
Enables the use of the Xshape extension
.Sp
By default, Enabled
.IP "\-\-enable\-xinerama" 4
.IX Item "--enable-xinerama"
Enables xinerama (Multi\-Monitor in X11) support
.Sp
By default, Disabled
.IP "\-\-enable\-menus" 4
.IX Item "--enable-menus"
Enables menu support (It's useful to turn this off if you rely
completely on a desktop environment using the root window)
.Sp
By default, Enabled
.IP "\-\-enable\-harbour" 4
.IX Item "--enable-harbour"
Enables the use of the harbour wich is used to swallow Window Maker
dockapps.
.Sp
By default, Enabled
.IP "\-\-enable\-pcre" 4
.IX Item "--enable-pcre"
Enables the use of libpcre for autoprops regular expressions. Note that
regular expressions are used no matter what; this option only makes
pcre be used instead of libc for them.
.Sp
By default, Disabled
.IP "\-\-enable\-debug" 4
.IX Item "--enable-debug"
Enables debugging output
.Sp
By default, Disabled
.IP "\-\-enable\-xft" 4
.IX Item "--enable-xft"
Enables Xft font support in pekwm (themes).
.Sp
By default, Enabled
.IP "\-\-enable\-image\-xpm" 4
.IX Item "--enable-image-xpm"
\&\s-1XPM\s0 image support using libXpm.
.Sp
By default, Enabled
.IP "\-\-enable\-image\-jpeg" 4
.IX Item "--enable-image-jpeg"
\&\s-1JPEG\s0 image support using libjpeg.
.Sp
By default, Enabled
.IP "\-\-enable\-image\-png" 4
.IX Item "--enable-image-png"
\&\s-1PNG\s0 image support using libpng.
.Sp
By default, Enabled
.IP "\-\-enable\-xrandr" 4
.IX Item "--enable-xrandr"
Enable the \s-1XRANDR\s0 extension support.
.Sp
By default, Enabled
.IP "\-\-prefix=PREFIX" 4
.IX Item "--prefix=PREFIX"
It may be useful to use a custom prefix to install the files.
.Sp
By default, /usr/local
.PP
\&\-\-\-\-
.Sh "3.3. Building and installing"
.IX Subsection "3.3. Building and installing"
After running ./configure with any options you need, run \fBmake\fR. This
should only take a few minutes. After that, become root (unless you
used a prefix in your home directory, such as \-\-prefix=/home/you/pkg)
and type \fBmake install\fR
.PP
Adding \fBexec pekwm\fR to \f(CW\*(C`~/.xinitrc\*(C'\fR if you start X running \fBstartx\fR
or \f(CW\*(C`~/.xsession\*(C'\fR if you use a display manager should usually be enough
to get pekwm running.
.PP
That's it! pekwm is installed on your computer now. Next you should
read the Getting Started chapter.
.SH "II. Basic Usage"
.IX Header "II. Basic Usage"
Pekwm is a fast, functional, and flexible window manager. Here's some
notes on how to operate it on it's default settings.
.IP "Table of Contents" 4
.IX Item "Table of Contents"
.PD 0
.IP "4. Getting Started" 4
.IX Item "4. Getting Started"
.IP "5. Window Grouping" 4
.IX Item "5. Window Grouping"
.IP "6. Workspaces" 4
.IX Item "6. Workspaces"
.PD
.PP
\&\-\-\-\-
.SH "Chapter 4. Getting Started"
.IX Header "Chapter 4. Getting Started"
Now that you have pekwm installed, you should take a few moments to
test how the basics work.
.PP
The documentation generally tries to explain the terms it uses, but
usefull terms to know beforehand include \*(L"Mod1\*(R" wich usually means your
Alt key, and \*(L"Mod4\*(R" wich refers to the \*(L"windows key\*(R" found on recen t
keyboards.
.PP
It's also good to know that a \*(L"frame\*(R" basically means the same as a
window, but this window can contain one or more real windows. The same
concept is also referred as a \*(L"window group\*(R". In relation to this,
window inside such a frame can be referred as a \*(L"grouped window\*(R" or a
\&\*(L"client window\*(R", or simply just as a \*(L"client\*(R".
.PP
\&\-\-\-\-
.Sh "4.1. First Run"
.IX Subsection "4.1. First Run"
The first time you run pekwm, the following files should be copied into
your \f(CW\*(C`~/.pekwm\*(C'\fR directory: \f(CW\*(C`config\*(C'\fR, \f(CW\*(C`menu\*(C'\fR, \f(CW\*(C`keys\*(C'\fR,
\&\f(CW\*(C`autoproperties\*(C'\fR, \f(CW\*(C`start\*(C'\fR, \f(CW\*(C`vars\*(C'\fR. You will learn more about these
files in the Configuration section.
.PP
All this happens behind\-the\-scenes, so by default, you'll be placed
into a nice working environment.
.PP
\&\-\-\-\-
.Sh "4.2. About Menus and Iconification"
.IX Subsection "4.2. About Menus and Iconification"
When you Iconify (This is the traditional name in unix. Windows calls
this minimizing.) a window in pekwm, it doesn't really go anywhere like
you might expect. You can de-iconify using one of three menus: The Icon
menu, the Goto menu, or the GotoClient menu. When you click on an item
in one of these menus, it takes you to that window deiconifying when
necessary.
.PP
Icon menu shows you a list of all currently iconified windows. Use
Mod4+Shift+I to bring it up.
.PP
Goto menu shows you a list of windows currently active. This menu will
only show the currently active window of possible window groups. Use
Mod4+L, or middle click of the mouse on the root window or screen edges
to bring this menu up.
.PP
GotoClient menu shows you a list of every window currently open. Window
groups are separated from eachother with a menu separator wich is
defined by the currently used theme, usually a line of some sort. You
need to be using window grouping to really see any difference between
the GotoClient and Goto menus. Use Mod4+C, or middle click of the mouse
on the root window or screen edges while holding down Mod4 to bring up
the GotoClient menu.
.PP
An Item in the goto and gotoclient menu and icon menu (and attach
menus) has the following syntax:
.PP
.Vb 1
\& <number> (NxN) [symbols] Window title
.Ve
.PP
The number represents what workspace the window is on. The two N's show
on what part of the viewport the window is. Symbols is a list of
symbols that represent window states. They are:
.PP
Symbols in the pekwm menus
.IP "\(bu" 4
* (sticky)
.IP "\(bu" 4
\&. (iconified)
.IP "\(bu" 4
^ (shaded)
.IP "\(bu" 4
+ (above normal window layer)
.IP "\(bu" 4
\&\- (below normal window layer)
.IP "\(bu" 4
A (active in group)
.Sp
.RS 4
If you are using window grouping, the whole group will iconify instead
of one window. Please ungroup before minimizing if you wish to iconify
a single client window from a group frame.
.RE
.PP
\&\-\-\-\-
.Sh "4.3. Using the mouse"
.IX Subsection "4.3. Using the mouse"
Pekwm has excellent mouse support. Here you'll learn how to do some
usual window management actions using the default configuration.
.PP
Moving windows is rather easy and I think you already got the hang of
using the left mouse button on the titlebar and dragging. But did you
notice that when you press Mod1 while dragging on the client window
(not the titlebar) it works just as well.
.PP
Resizing is also easy and most are familiar with it. Hang on to a
border of the window with the left mouse button and drag. Release the
button and you're done. But what you likely didn't know is that if you
press Mod1 and then drag on the client window with the right mouse
button it also makes windows resize. Try it, it's great.
.PP
Minimizing (iconifying) with the mouse is possible thru the window
menu. Right click on a windows titlebar and select Iconify. Many themes
also implement a iconifying button on the titlebar. Also see About
Menus and Iconification.
.PP
Shading is done by double clicking the titlebar with the middle mouse
button. Unshade doing it again.
.PP
Maximizing is quite easy. Most themes have a maximize button in them.
The default theme has one on the right corner of the titlebar. It's
also possible to use the window menu (right click on titlebar).
.PP
Filling. Sounds odd? Its not. It just means you can make a window grow
as large as it can until it hits the borders of the windows surrounding
it. Easy as pie, double click on the titlebar with the left mouse
button. Excellent feature you are likely to grow to like.
.PP
Raising windows. Easy. Left click on the windows titlebar or hold Mod1
and left click anywhere on the window.
.PP
Lowering windows. Hold Mod4 and left click anywhere on the window.
.PP
Closing. Most themes implement a close button. Default theme has one on
the left end of the titlebar. You can also close a client by holding
Mod4 and right clicking on its title. Note that the client doesn't have
to be the active client of the frame for this to work. Also see the
window menu.
.PP
Grouping. Middle click and drag on a titlebar and release over the
frame you want the window into. Holding Mod1 and middle clicking works
on the whole client window. This process can also be automated, more on
that later.
.PP
Activating clients. Now that you have multiple clients grouped into one
frame, you can switch between them simply by left clicking on the
clients title. Doing so also raises the frame. If you don't want the
frame to raise, middle click on the clients title. Also try turning the
mouse wheel on a frames titlebar when it has more than one client.
.PP
Menus. As mentioned, press the right mouse button on a windows titlebar
and you get the window menu. You can do lots of things from there that
are not possible by mouse shortcuts. To bring up the root menu (the one
you use to launch programs) click the right button on the background or
on the screen edges. To get the Goto menu, click the middle button on
the background or screen edges.
.PP
Most theme buttons work with a left click. Some also have specials when
you use other mouse buttons on them. Like the default themes maximize
button. Try it. The default themes close button also has a special when
you right click on it. With it it is possible to kill the client if
it's so stuck you can't close it normally.
.PP
That ends our short introduction to using the mouse in pekwm. Hope you
found the defaults pleasant to use. Remember that if you didn't like
something, you can change it. See Mouse Bindings for how.
.PP
\&\-\-\-\-
.Sh "4.4. Using the keyboard"
.IX Subsection "4.4. Using the keyboard"
Pekwm allows excellent keyboard control of your window management. Lets
try it out a bit. If you don't have the windows key on your keyboard,
please see \f(CW\*(C`~/.pekwm/keys\*(C'\fR for the keychains you can use to do the
same and a lot more.
.PP
Moving and Resizing windows. To be able to move and resize windows you
have to activate the special MoveResize state. This happens by pressing
Mod4+Enter. The window should after this be movable by using the arrow
keys. To resize, press Mod4 and use the arrows. Using the Shift-key
with these actions makes them be careful. To accept the new size and
position, press Enter. To fail back to the old position and size press
Escape.
.PP
Minimizing. Press Mod4+I. Mod4+Shift+I pops up the icon menu you can
use to bring it back.
.PP
Shading. This is to hide most of the window, leaving only the titlebar
visible. Press Mod4+S to toggle the shaded state.
.PP
Maximizing. Mod4+M toggles the maximized state.
.PP
Filling (making a window grow as big as it can in the space it has
around it). Press Mod4+G to make windows grow to fit.
.PP
Fullscreen. Press Mod4+F to toggle the fullscreen state.
.PP
Moving between frames. Press Mod1+Tab and Mod1+Shift+Tab to move
between frames. Or use Mod1+Ctrl+Tab and Mod1+Ctrl+Shift+Tab to move
between most recently used frames. You can also use directional
fucusing. Press Mod4 and one of the arrow keys. The focus should change
to the frame that is in the direction you pointed to. Try it out.
.PP
Moving inside frames. Press Mod4+Tab and Mod4+Shift+Tab to move between
the clients in a frame.
.PP
Closing. Press Mod4+Q to close windows.
.PP
Grouping. The easiest way to group is to use marking. You select
clients you want to group to another frame by toggling them marked with
Mod4+Z. You can have as many marked clients as you wish. Then go to the
frame you want those now marked clients to be attached and press
Mod4+A. That's it.
.PP
Menus. There are some simple menu bindings. Mod4+R shows your main menu
(the Root menu). Mod4+L shows a list of your active windows (the Goto
menu). Mod4+C shows a list of all your open windows (the Goto menu).
Mod4+W brings up the Window menu. And Mod4+Shift+I the Icon menu.
.PP
Those were the basics. There's a ton more. See the rest of the
documentation for rest of the simple bindings and \f(CW\*(C`~/.pekwm/keys\*(C'\fR for
a list of the keychains. And again, if you hated something, go ahead
and edit it.
.PP
\&\-\-\-\-
.SH "Chapter 5. Window Grouping"
.IX Header "Chapter 5. Window Grouping"
The main feature of pekwm is window grouping, similar to that of ion,
or the tabs in pwm or fluxbox.
.PP
\&\-\-\-\-
.Sh "5.1. What is window grouping?"
.IX Subsection "5.1. What is window grouping?"
Window grouping is a very simple concept, but it could be hard to
understand at first. It's a simple way of making multiple applications
share the exact same space.
.PP
The simplest way to explain this is with an analogy. Imagine you have
20 sheets of paper. To save space, you stack them on top of eachother.
then, you have little tabs sticking out of one edge so you can quickly
flip to any sheet of paper.
.PP
You have likely stumbled upon a WWW-browser that calls this tabbing. In
pekwm, Window grouping is visually done by dividing up the physical
space of the titlebar. We don't call them tabs for historical reasons,
but refer to them as \*(L"clients\*(R". Windows that can contain any number of
clients are more than often referred as \*(L"frames\*(R".
.PP
Also note that a frame can contain any type of clients. If you want to
group one of your WWW-browser windows with your text editor for future
reference, you're free to do so.
.PP
\&\-\-\-\-
.Sh "5.2. How window grouping works"
.IX Subsection "5.2. How window grouping works"
The first thing to know is how to group one window to another.
Middle-Click (On a normal X setup, the 2nd mouse button is the middle
button) the titlebar of the first window and begin to drag the window.
You should now see a rectangle with the window's title in it. Drag that
rectangle to above the target window, and release your mouse button.
.Sp
.RS 4
Any time this document mentions a key or mouse button, there's a strong
likelyhood that you can change which key or mouse button is used for
that function. Please see the Keyboard and Mouse config section.
.RE
.PP
Now that you have windows in a group, you need to learn to choose
between windows in that group. The first way is by clicking the middle
mouse button on the window's part of the titlebar. That window should
now be the currently-active window of the group. You can also use a
keybinding for this. The default keybindings are Mod4+Tab and
Mod4+Shift+Tab to go forward and back between active window in the
frame.
.PP
To de\-group, simply middle click and drag the window off the frame, and
release anywhere. If you release over another window group, you'll move
the window to the new group. Default keybinding for detaching clients
from a group is first Ctrl+Mod1+T then D.
.PP
You can also set windows up to automatically be grouped to one another.
See the Autoproperties section for more details.
.PP
\&\-\-\-\-
.Sh "5.3. Advanced Grouping Topics"
.IX Subsection "5.3. Advanced Grouping Topics"
Another thing you can do with window grouping is Tagging. This is done
by setting the toggleable attribute \*(L"tagged\*(R" on a frame with the action
\&\*(L"Set Tagged\*(R". A tag is like a miniature autogroup. It says \*(L"All new
windows launched should be automatically grouped to this Frame\*(R" and all
other autogrouping defined in the autoproperties will be ignored while
it is set. \*(L"UnSet Tagged\*(R" removes the tag. Default keybinding to toggle
tagging on a frame is Ctrl+Mod1+T then T. Unsetting tagging works even
if the window you have set tagged isn't active. It's default keybinding
is Ctrl+Mod1+T then C.
.PP
You can toggle all autogrouping on and off with the toggleable
attribute GlobalGrouping. To disable you need to use the action \*(L"Unset
GlobalGrouping\*(R" and to enable autogrouping use \*(L"Set GlobalGrouping\*(R".
The default keybinding that toggless between set and unset is
Ctrl+Mod1+T then G.
.PP
You can set a marked state on clients with \*(L"set marked\*(R" and then attach
those marked clients to another frame by focusing the frame you want
the marked clients attached to and then using the AttachMarked action.
By default marking can be reached with two simple keybindings. Mod4+Z
toggles a clients Marked state and Mod4+A attachs clients with marked
state set into the current frame.
.PP
Pekwm also includes some menus that have to do with grouping.
AttachClientInFrame (Ctrl+Mod1+M, A) sends the current client to the
selected frame. AttachFrameInFrame (Ctrl+Mod1+M, F) sends the contents
of the current frame to the selected frame. AttachClient (Ctrl+Mod1+M,
Shift+A) brings the selected client into the current frame. AttachFrame
(Ctrl+Mod1+M, Shift+F) brings the contents of the selected frame into
the current frame.
.PP
\&\-\-\-\-
.SH "Chapter 6. Workspaces"
.IX Header "Chapter 6. Workspaces"
Workspaces in pekwm are a very common feature, found in almost every
\&\s-1UNIX\s0 window manager in existence. They're also called desktops in some
window managers. In Pekwm\-Speak, \*(L"workspace\*(R", \*(L"desktop\*(R", and \*(L"desk\*(R" are
interchangeable. Use whichever one you feel like using.
.Sp
.RS 4
By default, pekwm enables four workspaces. You can change this by
editing your \f(CW\*(C`~/.pekwm/config\*(C'\fR file. See The main config file section
for more details.
.RE
.PP
\&\-\-\-\-
.Sh "6.1. Workspace Navigation"
.IX Subsection "6.1. Workspace Navigation"
You can send windows to another workspace by right-clicking the
titlebar, going to 'send to' and picking the desktop you'd like.
Another option is using the SendToWorkspace keybindings (by default,
Mod4 and one of F1, F2, F3, or F4). Using the mouse to drag a window
over the right or left screen edge makes it move to the next or
previous workspace. Also try placing the mouse pointer on a client
window and rotatign the mouse wheel while holding Mod1 down to send a
window to the next or previous workspace and follow it there yourself.
.PP
Switch desktops by using the GoToWorkspace keybindings (by default Mod4
and one of 1,2,3, or 4), or the \*(L"GotoWorkspace Next\*(R" and \*(L"GotoWorkspace
Prev\*(R" actions (by default Ctrl+Mod1+Right and Ctrl+Mod1+Left). Holding
Mod1 key while moving the mouse pointer over the right or left screen
edge will make you move to the next or previous workspace. Also
pressing the left mouse button on the right or left screen edge will
make you move to the next or previous workspace. Using the mouse wheel
on the background or the screen edges also changes your workspace.
.PP
\&\-\-\-\-
.Sh "6.2. Viewports"
.IX Subsection "6.2. Viewports"
Viewports are workspaces that are larger than the visible screensize.
This means you can have a big workspace in wich you scroll around
freely. By default pekwm uses a viewport that is 1x1 in size. This
effectively means that viewports are disabled. If you increase these
numbers from \f(CW\*(C`~/.pekwm/config\*(C'\fR to 3x3 (a three times three square),
you should be able to browse thru your now 9 times bigger workspaces
viewports with Mod4 and the keypad number keys. Also try dragging the
root window (background) with your left mouse button. More ways are
holding Mod4 and moving the mouse pointer over a screen edge or moving
the mouse to a screen edge and then pressing Mod4 and the left mouse
button.
.PP
Usually when you drag windows over your left or right screen edge, it
will be moved to another workspace. However, when you press Mod4 while
dragging the windows, they will move around in your viewport. Usually
viewports are defined as squares, so also try dragging over the upper
and lower screen edges.
.PP
Viewports are sometimes considered hard to visualize. To help this the
default keybindings to move around your viewport are arranged to your
keypad numbers. If you enable a 3x3 viewport, you can move around it
with Mod4 and the keypad numbers. Mod4+1 takes you to the lower left
segment of your viewport, Mod4+9 to the upper right, Mod4+5 to the
center and so on. Instead of thinking under what number your window is,
imagine it being \*(L"up on the left\*(R" or \*(L"down in the center\*(R". Also
consider using a pager application that handles viewports.
.PP
People usually disable multiple workspaces when they start using
viewports to avoid getting lost. However if you feel you aren't getting
lost, nothing stops you from using for example, ten workspaces with a
10x10 viewport.
.SH "III. Configuration"
.IX Header "III. Configuration"
The configuration part of this documentation is focused on providing
complete documentation for all config files located in your \f(CW\*(C`~/.pekwm\*(C'\fR
directory.
.IP "Table of Contents" 4
.IX Item "Table of Contents"
.PD 0
.IP "7. The Pekwm Common Syntax for Config Files" 4
.IX Item "7. The Pekwm Common Syntax for Config Files"
.IP "8. The main config file" 4
.IX Item "8. The main config file"
.IP "9. Configuring the menus" 4
.IX Item "9. Configuring the menus"
.IP "10. Autoproperties" 4
.IX Item "10. Autoproperties"
.IP "11. Keyboard and Mouse Configuration" 4
.IX Item "11. Keyboard and Mouse Configuration"
.IP "12. The pekwm start file" 4
.IX Item "12. The pekwm start file"
.IP "13. Pekwm themes" 4
.IX Item "13. Pekwm themes"
.PD
.PP
\&\-\-\-\-
.SH "Chapter 7. The Pekwm Common Syntax for Config Files"
.IX Header "Chapter 7. The Pekwm Common Syntax for Config Files"
\&\-\-\-\-
.Sh "7.1. Basic Syntax"
.IX Subsection "7.1. Basic Syntax"
All pekwm config files (with the exception of the start file\- see start
file ) Follow a common syntax for options.
.PP
.Vb 5
\& # comment
\& // another comment
\& /*
\&         yet another comment
\& */
.Ve
.PP
.Vb 4
\& $VAR = "Value"
\& $_VARIABLE = "Value"
\& INCLUDE = "vars"
\& COMMAND = "program to execute and add the valid config syntax it outputs here"
.Ve
.PP
.Vb 6
\& # Normal format
\& Section = "Name" {
\&         Event = "Param" {
\&                 Actions = "action parameter; action parameter; $VAR $_VARIABLE"
\&         }
\& }
.Ve
.PP
.Vb 2
\& // Compressed format
\& Section = "Name" { Event = "Param" { Actions = "action parameters; action parameters; $VAR $_VARIABLE" } }
.Ve
.PP
You can usually modify the spacing and line breaks, but this is the
\&\*(L"Correct\*(R" format, so the documentation will try to stick to it.
.PP
Events can be combined into the same line by issuing a semicolon
between them. Actions can be combined into the same user action by
issuing a semicolon between them. You can use an \s-1INCLUDE\s0 anywhere in
the file.
.PP
Pekwm has a \f(CW\*(C`vars\*(C'\fR file to set common variables between config files.
Variables are defined in \f(CW\*(C`vars\*(C'\fR and the file is INCLUDEd from the
configuration files.
.PP
Comments are allowed in all config files, by starting a comment line
with # or //, or enclosing the comments inside /* and */.
.PP
\&\-\-\-\-
.Sh "7.2. Variables In Pekwm Config Files"
.IX Subsection "7.2. Variables In Pekwm Config Files"
Pekwm config enables you to use both internal to pekwm variables, as
well as global system variables. Internal variables are prefixed with a
\&\fB$\fR, global variables with \fB$_\fR.
.PP
.Vb 3
\& # examples of how to set both type of variables
\& $INTERNAL = "this is an internal variable"
\& $_GLOBAL = "this is a global variable"
.Ve
.PP
.Vb 4
\& # examples of how to read both type of variables
\& RootMenu = "Menu" {
\&         Entry = "$_GLOBAL" { Actions = "xmessage $INTERNAL" }
\& }
.Ve
.PP
There is one special global variable pekwm handles. It is called
\&\f(CW$_PEKWM_CONFIG_FILE\fR. This global variable is read when pekwm starts,
and it's contents will be used as the default config file. It will also
be updated to point to the currently active config file if needed.
.PP
Variables can probably be defined almost anywhere, but it's probably a
better idea to place them at the top of the file, outside of any
sections.
.PP
\&\-\-\-\-
.SH "Chapter 8. The main config file"
.IX Header "Chapter 8. The main config file"
The main config file is where all the base config stuff goes.
.PP
\&\-\-\-\-
.Sh "8.1. Basic Config"
.IX Subsection "8.1. Basic Config"
As previously indicated, the config file follows the rules defined in
Common Syntax.
.PP
Here's an example \f(CW\*(C`~/.pekwm/config\*(C'\fR file:
.PP
.Vb 8
\& Files {
\&         Keys = "~/.pekwm/keys"
\&         Mouse = "~/.pekwm/mouse"
\&         Menu = "~/.pekwm/menu"
\&         Start = "~/.pekwm/start"
\&         AutoProps = "~/.pekwm/autoproperties"
\&         Theme = "~/.pekwm/themes/default"
\& }
.Ve
.PP
.Vb 8
\& MoveResize {
\&         EdgeAttract = "10"
\&         EdgeResist = "10"
\&         WindowAttract = "5"
\&         WindowResist = "5"
\&         OpaqueMove = "True"
\&         OpaqueResize = "False"
\& }
.Ve
.PP
.Vb 6
\& Screen {
\&         Workspaces = "4"
\&         ShowFrameList = "True"
\&         PlaceNew = "True"
\&         FocusNew = "True"
\&         ShowStatusWindow = "True"
.Ve
.PP
.Vb 5
\&         TrimTitle = "..."
\&         EdgeSize = "1"
\&         PixmapCacheSize = "20"
\&         ImlibAntiAlias = "True"
\&         DoubleClickTime = "250"
.Ve
.PP
.Vb 8
\& Placement {
\&                 Model = "CenteredOnParent Smart MouseCentered"
\&                 Smart {
\&                         Row = "False"
\&                         TopToBottom = "True"
\&                         LeftToRight = "True"
\&                 }
\&         }
.Ve
.PP
.Vb 5
\&         UniqueNames {
\&                 SetUnique = "True"
\&                 Pre = " #";
\&                 Post = "";
\&         }
.Ve
.PP
.Vb 8
\&         Viewports {
\&                 Columns = "1"
\&                 Rows = "1"
\&                 # Viewports are disabled by default to avoid strange behaviour from buggy pagers
\&                 #Columns = "3"
\&                 #Rows = "3"
\&         }
\& }
.Ve
.PP
.Vb 5
\& Menu {
\&         Select = "Motion"
\&         Enter = "Motion ButtonPress"
\&         Exec = "ButtonRelease"
\& }
.Ve
.PP
.Vb 6
\& Harbour {
\&         OnTop = "True"
\&         MaximizeOver = "False"
\&         Placement = "Right"
\&         Orientation = "TopToBottom"
\&         Head = "0"
.Ve
.PP
.Vb 5
\&         DockApp {
\&                 SideMin = "64"
\&                 SideMax = "64"
\&         }
\& }
.Ve
.PP
\&\-\-\-\-
.Sh "8.2. Config File Keywords"
.IX Subsection "8.2. Config File Keywords"
Here's a table showing the different elements that can be used in your
\&\f(CW\*(C`config\*(C'\fR file. Remember that 'boolean' means 'true' or 'false' and
that all values should be placed inside quotes.
.PP
Config File Elements under the Files\-section:
.IP "Keys (string)" 4
.IX Item "Keys (string)"
The location of the keys file, such as \f(CW\*(C`~/.pekwm/keys\*(C'\fR
.IP "Menu (string)" 4
.IX Item "Menu (string)"
The location of the menu file, such as \f(CW\*(C`~/.pekwm/menu\*(C'\fR
.IP "Start (string)" 4
.IX Item "Start (string)"
The location of the start file, such as \f(CW\*(C`~/.pekwm/start\*(C'\fR
.IP "AutoProps (string)" 4
.IX Item "AutoProps (string)"
The location of the autoprops file, such as \f(CW\*(C`~/.pekwm/autoproperties\*(C'\fR
.IP "Theme (string)" 4
.IX Item "Theme (string)"
The location of the Theme directory, such as
\&\f(CW\*(C`~/.pekwm/themes/themename\*(C'\fR
.PP
Config File Elements under the MoveResize\-section:
.IP "EdgeAttract (int)" 4
.IX Item "EdgeAttract (int)"
The distance from screen edge required for the window to snap against
it in pixels.
.IP "EdgeResist (int)" 4
.IX Item "EdgeResist (int)"
The distance from screen edge required for the window moving to start
being resisted in pizels.
.IP "WindowAttract (int)" 4
.IX Item "WindowAttract (int)"
The distance from other clients that a window will snap against them to
in pixels.
.IP "WindowResist (int)" 4
.IX Item "WindowResist (int)"
The distance from other clients that a window movement will start being
resisted.
.IP "OpaqueMove (boolean)" 4
.IX Item "OpaqueMove (boolean)"
If true, turns on opaque Moving
.IP "OpaqueResize (boolean)" 4
.IX Item "OpaqueResize (boolean)"
If true, turns on opaque Resizing
.PP
Config File Elements under the Screen\-section:
.IP "Workspaces (int)" 4
.IX Item "Workspaces (int)"
Number of workspaces enabled.
.IP "DoubleClicktime (int)" 4
.IX Item "DoubleClicktime (int)"
Time, in milliseconds, between clicks to be counted as a doubleclick.
.IP "ShowFrameList (boolean)" 4
.IX Item "ShowFrameList (boolean)"
Controls whether a list of all available frames on the workspace is
displayed during the FocusNextFrame/FocusPrevFrame actions.
.IP "ShowStatusWindow (boolean)" 4
.IX Item "ShowStatusWindow (boolean)"
Controls whether a size/position info window is shown when moving or
resizing windows.
.IP "EdgeSize (int)" 4
.IX Item "EdgeSize (int)"
How many pizels from the edge of the screen should screen edges be in
pixels. A value of 0 disables edges.
.IP "ImlibAntiAlias (boolean)" 4
.IX Item "ImlibAntiAlias (boolean)"
If true, antialiases images rendered with imlib2 (requires imlib2 to be
enabled at compile time).
.IP "PixmapCacheSize (int)" 4
.IX Item "PixmapCacheSize (int)"
Determines how many unused pixmaps are stored on the image cache for
future use.
.IP "FocusNew (boolean)" 4
.IX Item "FocusNew (boolean)"
Toggles if new windows should be focused when they pop up.
.IP "PlaceNew (boolean)" 4
.IX Item "PlaceNew (boolean)"
Toggles if new windows should be placed using the rules found in the
Placement subsection, or just opened on the top left corner of your
screen.
.IP "TrimTitle (string)" 4
.IX Item "TrimTitle (string)"
This string contains what pekwm uses to trim down overlong window
titles. If it's empty, no trimming down is performed at all.
.PP
Config File Elements under the Placement-subsection of the
Screen\-section:
.IP "Model (string)" 4
.IX Item "Model (string)"
.RS 4
.PD 0
.IP "*" 4
.PD
Smart \- Tries to place windows where no other window is present
.IP "*" 4
MouseCentered \- Places the center of the window underneath the current
mouse pointer position
.IP "*" 4
MouseTopLeft \- Places the top-left corner of the window under the
pointer
.IP "*" 4
MouseNotUnder \- Places windows on screen corners avoiding the current
mouse cursor position.
.IP "*" 4
CenteredOnParent \- Places transient windows at center of their parent
window.
.RE
.RS 4
.RE
.PP
Config File Elements under the Smart-subsection of the
Placement\-subsection:
.IP "Row (boolean)" 4
.IX Item "Row (boolean)"
Whether to use row or column placement, if true, uses row.
.IP "TopToBottom (boolean)" 4
.IX Item "TopToBottom (boolean)"
If false, the window is placed starting from the bottom.
.IP "LeftToRight (boolean)" 4
.IX Item "LeftToRight (boolean)"
If false, the window is placed starting from the right.
.PP
Config File Elements under the Viewports-subsection of the
Screen\-section:
.IP "Columns (int)" 4
.IX Item "Columns (int)"
Specifies the size of the viewport horizontally. Value is an integer as
n is in viewport_width=n*screenwidth.
.IP "Rows (int)" 4
.IX Item "Rows (int)"
Specifies the size of the viewport vertically. Value is an integer as n
is in viewport_height=n*screenheight.
.PP
Config File Elements under the UniqueNames-subsection of the
Screen\-section:
.IP "SetUnique (boolean)" 4
.IX Item "SetUnique (boolean)"
Decides if the feature is used or not. False or True.
.IP "Pre (string)" 4
.IX Item "Pre (string)"
String to place before the unique client number.
.IP "Post (string)" 4
.IX Item "Post (string)"
String to place after the unique client number.
.PP
Config File Elements under the Menu\-section:
.IP "Select (string)" 4
.IX Item "Select (string)"
Decides on what mouse events to select a menu entry. String is one of
\&\*(L"ButtonPress, ButtonRelease, DoubleClick, Motion\*(R"
.IP "Enter (string)" 4
.IX Item "Enter (string)"
Decides on what mouse events to enter a submenu. String is one of
\&\*(L"ButtonPress, ButtonRelease, DoubleClick, Motion\*(R"
.IP "Exec (string)" 4
.IX Item "Exec (string)"
Decides on what mouse events to execute an entry. String is one of
\&\*(L"ButtonPress, ButtonRelease, DoubleClick, Motion\*(R"
.PP
Config File Elements under the Harbour\-section:
.IP "Placement (string)" 4
.IX Item "Placement (string)"
Which edge to place the harbour on. One of Right, Left, Top, or Bottom.
.IP "Orientation (string)" 4
.IX Item "Orientation (string)"
From what to which direction the harbour expands. One of TopToBottom,
BottomToTop, RightToLeft, LeftToRight.
.IP "OnTop (boolean)" 4
.IX Item "OnTop (boolean)"
Whether or not the harbour is \*(L"always on top\*(R"
.IP "MaximizeOver (boolean)" 4
.IX Item "MaximizeOver (boolean)"
Controls whether maximized clients will cover the harbour (true), or if
they will stop at the edge of the harbour (false).
.IP "Head (int)" 4
.IX Item "Head (int)"
When Xinerama is on, decides on what head the harbour resides on.
Integer is the head number.
.PP
Config File Elements under the DockApp-subsection of the
Harbour\-section:
.IP "SideMin (int)" 4
.IX Item "SideMin (int)"
Controls the minimum size of dockapp clients. If a dockapp client is
smaller than the minimum, it gets resized up to the SideMin value.
Integer is a number of pixels.
.IP "SideMax (int)" 4
.IX Item "SideMax (int)"
Controls the maximum size of dockapp clients. If a dockapp client is
larger than the maximum, it gets resized down to the SideMax value.
Integer is a number of pixels.
.PP
\&\-\-\-\-
.Sh "8.3. Screen Subsections"
.IX Subsection "8.3. Screen Subsections"
There are three subsections in the screen section \- Placement,
Viewports and ClientUniqueNames. Placement can optionally have it's own
subsection. Sound hard? It's not! It's really quite simple.
.PP
We'll start off with Placement. Placement has two options: Model, and a
\&'Smart' subsection. Model is very simple, it's simply a list of
keywords that describes how to place new windows, such as \*(L"Smart
MouseCentered\*(R". Secondly, there's a Smart section, which describes how
pekwm computes where to place a new window in smart mode.
.PP
The second subsection is for viewports configuration. With it you can
manage the layout of your viewports. See Viewports for more info on
viewports.
.PP
Third subsection, UniqueNames, lets you configure how pekwm should
handle similar client names. Pekwm can add unique number identifiers to
clients that have the same title so that instead of \*(L"terminal\*(R" and
\&\*(L"terminal\*(R", you would end up with something like \*(L"terminal\*(R" and
\&\*(L"terminal [2]\*(R".
.PP
\&\-\-\-\-
.SH "Chapter 9. Configuring the menus"
.IX Header "Chapter 9. Configuring the menus"
The root menu is what you get when you (by default\- See the Mouse
Bindings section) left-click on the root window (also called the
desktop). You can also configure the window menu, which you get when
you right-click on a window title.
.PP
\&\-\-\-\-
.Sh "9.1. Basic Menu Syntax"
.IX Subsection "9.1. Basic Menu Syntax"
As previously indicated, the root menu follows the rules defined in
Common Syntax. There aren't many possible options, and they're all
either within the main menu, or within a submenu. This is all handled
by a single file.
.PP
Here's an example \f(CW\*(C`~/.pekwm/menu\*(C'\fR file:
.PP
.Vb 1
\& # Menu config for pekwm
.Ve
.PP
.Vb 2
\& # Variables
\& $TERM = "xterm -fn fixed +sb -bg black -fg white"
.Ve
.PP
.Vb 38
\& RootMenu = "Pekwm" {
\&         Entry = "Term" { Actions = "Exec $TERM &" }
\&         Entry = "Emacs" { Actions = "Exec $TERM -title emacs -e emacs -nw &" }
\&         Entry = "Vim" { Actions = "Exec $TERM -title vim -e vi &" }
\&         Separator {}
\&         Submenu = "Graphics" {
\&                 Entry = "Gimp" { Actions = "Exec gimp &" }
\&                 Entry = "Gv" { Actions = "Exec gv &" }
\&                 Entry = "Xpdf" { Actions = "Exec xpdf &" }
\&         }
\&         Submenu = "Mm" {
\&                 Entry = "Xmms" { Actions = "Exec xmms &" }
\&                 Entry = "MPlayer" { Actions = "Exec mplayer &" }
\&         }
\&         Submenu = "Utils" {
\&                 Entry = "XCalc" { Actions = "Exec xcalc &" }
\&                 Entry = "XMan" { Actions = "Exec xman &" }
\&         }
\&         Submenu = "WwW" {
\&                 Entry = "Dillo" { Actions = "Exec dillo &" }
\&                 Entry = "Konqueror" { Actions = "Exec konqueror www.google.com &" }
\&                 Entry = "Mozilla" { Actions = "Exec mozilla &" }
\&                 Entry = "Mutt" { Actions = "Exec $TERM -title mutt -e mutt &" }
\&         }
\&         Separator {}
\&         Submenu = "Pekwm" {
\&         Entry = "Reload" { Actions = "Reload" }
\&         Entry = "Restart" { Actions = "Restart" }
\&         Entry = "Exit" { Actions = "Exit" }
\&                 Submenu = "Others" {
\&                         Entry = "Xterm" { Actions = "RestartOther xterm" }
\&                         Entry = "Twm" { Actions = "RestartOther twm" }
\&                 }
\&                 Submenu = "Themes" {
\&                         Entry { Actions = "Dynamic ~/.pekwm/scripts/pekwm_themeset.pl" }
\&                 }
\&         }
\& }
.Ve
.PP
.Vb 3
\& WindowMenu = "Window Menu" {
\&         Entry = "(Un)Stick" { Actions = "Toggle Sticky" }
\&         Entry = "(Un)Shade" { Actions = "Toggle Shaded" }
.Ve
.PP
.Vb 31
\&         Submenu = "Maximize" {
\&                 Entry = "Full" { Actions = "Toggle Maximized True True" }
\&                 Entry = "Horizontal" { Actions = "Toggle Maximized True False" }
\&                 Entry = "Vertical" { Actions = "Toggle Maximized False True" }
\&         }
\&         Submenu = "Stacking" {
\&                 Entry = "Raise " { Actions = "Raise" }
\&                 Entry = "Lower" { Actions = "Lower" }
\&                 Entry = "Always On Top " { Actions = "Toggle AlwaysOnTop" }
\&                 Entry = "Always Below" { Actions = "Toggle AlwaysBelow" }
\&         }
\&         Submenu = "Decor" {
\&                 Entry = "Decor" { Actions = "Toggle DecorBorder; Toggle DecorTitlebar" }
\&                 Entry = "Border" { Actions = "Toggle DecorBorder" }
\&                 Entry = "Titlebar" { Actions = "Toggle DecorTitlebar" }
\&         }
\&         SubMenu = "Send To" {
\&                 Entry = "Workspace 1" { Actions = "SendToWorkspace 1" }
\&                 Entry = "Workspace 2" { Actions = "SendToWorkspace 2" }
\&                 Entry = "Workspace 3" { Actions = "SendToWorkspace 3" }
\&                 Entry = "Workspace 4" { Actions = "SendToWorkspace 4; GoToWorkspace 4" }
\&         }
\&         SubMenu = "Toggle Skip" {
\&                 Entry = "Menus" { Actions = "Toggle Skip Menus" }
\&                 Entry = "Focus Toggle" { Actions = "Toggle Skip FocusToggle" }
\&                 Entry = "Snap" { Actions = "Toggle Skip Snap" }
\&         }
\&         Entry = "Iconify " { Actions = "Toggle Iconified" }
\&         Entry = "Close" { Actions = "Close" }
\&         Entry = "Kill " { Actions = "Kill" }
\& }
.Ve
.PP
\&\-\-\-\-
.Sh "9.2. Menu Keywords"
.IX Subsection "9.2. Menu Keywords"
Here are the different elements that can be used in your root menu
file.
.PP
Root Menu Elements:
.IP "Submenu (Name)" 4
.IX Item "Submenu (Name)"
Begins a submenu. 'name' is what will appear in the root menu for the
entry.
.IP "Name (Name)" 4
.IX Item "Name (Name)"
Alternative way of saying \fBSubmenu = \*(L"name\*(R" {\fR. Start the submenu with
\&\fBSubmenu { Name = \*(L"name\*(R"\fR to use this feature.
.IP "Entry (Name)" 4
.IX Item "Entry (Name)"
Begins a menu entry. 'Name' is the text shown in the menu for this
entry.
.IP "Actions (Action)" 4
.IX Item "Actions (Action)"
Run an action. 'Action' is the action(s) to run. Most actions listed in
Keys/mouse actions will also work from the root and window menus.
.IP "Separator" 4
.IX Item "Separator"
Adds a separator to the menu.
.PP
Menu Actions:
.IP "Exec" 4
.IX Item "Exec"
Exec makes pekwm to execute the command that follows it. Make sure the
program gets backgrounded. Put an '&' at the end of the action if it
doesn't do this on it's own.
.IP "Reload" 4
.IX Item "Reload"
When this is called, pekwm will Re-read all configuration files without
exiting.
.IP "Restart" 4
.IX Item "Restart"
This will cause pekwm to exit and re-start completely.
.IP "RestartOther" 4
.IX Item "RestartOther"
Quits pekwm and starts another application. The application to run is
given as a parameter.
.IP "Exit" 4
.IX Item "Exit"
Exits pekwm. Under a normal X setup, This will end your X session.
.PP
\&\-\-\-\-
.Sh "9.3. Dynamic Menus"
.IX Subsection "9.3. Dynamic Menus"
It is possible to use dynamic menus in pekwm, that is menus that
regenerate themself whenever the menu is viewed. This is done with the
Dynamic keyword.
.PP
To use this feature, you need to put a dynamic entry in the
\&\f(CW\*(C`~/.pekwm/menu\*(C'\fR file with a parameter that tells pekwm what file to
execute to get the menu. This file can be of any language you prefer,
the main thing is that it outputs valid pekwm menu syntax inside a
Dynamic {} section. The syntax of dynamic entry looks like this:
.PP
.Vb 1
\& Entry = "" { Actions = "Dynamic /path/to/filename" }
.Ve
.PP
The input from a program that creates the dynamic content should follow
the general menu syntax encapsulated inside a Dynamic {} section.
Variables have to be included inside the dynamic menu for them to work.
A simple script to give pekwm dynamic menu content would look like
this:
.PP
.Vb 2
\& #!/bin/bash
\& output=$RANDOM # gets a random number
.Ve
.PP
.Vb 3
\& echo "Dynamic {"
\& echo " Entry = \e"$output\e" { Actions = \e"Exec xmessage $output\e" }"
\& echo "}"
.Ve
.PP
This script would output something like:
.PP
.Vb 3
\& Dynamic {
\&  Entry = "31549" { Actions = "Exec xmessage 31549" }
\& }
.Ve
.PP
\&\-\-\-\-
.SH "Chapter 10. Autoproperties"
.IX Header "Chapter 10. Autoproperties"
\&\-\-\-\-
.Sh "10.1. What are Autoproperties?"
.IX Subsection "10.1. What are Autoproperties?"
\&\*(L"Autoproperties\*(R" is short for \*(L"Automatic Properties\*(R". This is pekwm's
way of setting certain things up for applications based on the window's
internal id. You can set up a lot of things, such as Size, iconified
state, start location, grouped state (automatically having one window
group to another), workspace to start on, whether it has a border or
titlebar, and more. It is also possible to automatically modify window
titles and to decide the order of applications on the harbour with
autoproperties.
.PP
\&\-\-\-\-
.Sh "10.2. Basic Autoproperties Syntax"
.IX Subsection "10.2. Basic Autoproperties Syntax"
The \f(CW\*(C`~/.pekwm/autoproperties\*(C'\fR file follows the rules in Common Syntax.
This file can become rather complicated, but it's also the most
powerful of any of pekwm's config files.
.PP
The one important thing to remember is the Property tag. This
identifier tells us where to apply properties. It means which windows
to apply it on. To find out the two terms, use \fBxprop \s-1WM_CLASS\s0\fR and
click on your window. Below you'll find a bash/zsh function which will
give you the correct string for this file. You can also specify a
regexp wildcard, such as \*(L".*,opera\*(R", which means anything for the first
word, opera for the second.
.PP
.Vb 5
\& propstring () {
\&   echo -n 'Property '
\&   xprop WM_CLASS | sed 's/.*"\e(.*\e)", "\e(.*\e)".*/= "\e1,\e2" {/g'
\&   echo '}'
\& }
.Ve
.PP
In addition with \s-1WM_CLASS\s0, pekwm also can identify clients by their
title string (\fBxprop \s-1WM_NAME\s0\fR).
.PP
.Vb 5
\& Property = "^dillo,^Dillo" {
\&         Title = "Dillo: pekwm.org - not just another windowmanager"
\&         ApplyOn = "Start New"
\&         Layer = "OnTop"
\& }
.Ve
.PP
Or by their role (\fBxprop \s-1WM_WINDOW_ROLE\s0\fR):
.PP
.Vb 5
\& Property = "^gaim,^Gaim" {
\&         Role = "preferences"
\&         ApplyOn = "New"
\&         Skip = "Menus"
\& }
.Ve
.PP
Pekwm can rewrite window titles. This is done in a separate TitleRules
section, where one defines properties on wich clients to use the
rewriting and then a regexp rule of what to do to that clients title.
These rules do not affect the actual \s-1WM_NAME\s0 string. You can use Role
and Title keywords to narrow down the clients the titlerule applies to.
A simple rule that would change \*(L"Title: this is the title\*(R" to \*(L"this is
the title\*(R" looks like this:
.PP
.Vb 5
\& TitleRules {
\&         Property = "^foo,^bar" {
\&                 Rule = "/Title: (.*)/\e\e1/"
\&         }
\& }
.Ve
.PP
In pekwm, you can make certain windows have their own decoration set.
The different decorations are defined in the theme, and they are
connected to client windows with an autoproperty. These autoproperties
reside in their own DecorRules subsection and look like this:
.PP
.Vb 5
\& DecorRules {
\&         Property = "^foo,^bar" {
\&                 Decor = "TERM"
\&         }
\& }
.Ve
.PP
It's also possible to decide the order of applications that start in
the harbour. As with TitleRules and DecorRules, there is it's own
separate section for this purpose called Harbour. Position is a signed
int and order goes: \*(L"1 2 3 0 0 0 \-3 \-2 \-1\*(R", and so on. That looked
cryptic. Worry not. Basically, a Position number of 0 means the
application will be placed in the middle. If the number is positive,
the application will be placed before the zero-positioned applications.
If the number is negative, they applications will be placed after the
zero-position ones. So the positive numbered show up first in your
harbour, then the zero numbered, and after the zeros come the
negatively numbered applications. I hope that is clear, the next part
is tricky. The larger the value of the base number the closer to the
zero applications they will be. So the smaller the base number the
closer to the ends of the harbour the application will be. Position 1
would be the first application to show up on the harbour. And similarly
Position \-1 would be the last application on the harbour. If you have
application on the harbour that do not match any of the property rules
on the Harbour section, they will act as if you had given them Position
0. Applications with the same Position will show up next to eachother
in the order they are launched. In our example below, obpager will
allways be placed the last on the harbour.
.PP
.Vb 5
\& Harbour {
\&         Property = "^obpager,^obpager" {
\&                 Position = "-1";
\&         }
\& }
.Ve
.PP
Here's an example \f(CW\*(C`~/.pekwm/autoproperties\*(C'\fR file:
.PP
.Vb 5
\& Property = ".*,^xmms" {
\&         ApplyOn = "Start New"
\&         Layer = "0"
\&         Sticky = "True"
\& }
.Ve
.PP
.Vb 7
\& Property = "^xclock,^XClock" {
\&         ApplyOn = "Start New"
\&         FrameGeometry = "100x100+0-0"
\&         Border = "False"; Titlebar = "False"
\&         Sticky = "True"
\&         Layer = "Desktop"
\& }
.Ve
.PP
.Vb 8
\& Property = "^dillo,^Dillo" {
\&         ApplyOn = "Start New"
\&         Group = "browsers" {
\&                 Size = "30"
\&                 Behind = "True"
\&                 Global = "False"
\&         }
\& }
.Ve
.PP
.Vb 8
\& TitleRules {
\&         Property = "^dillo,^Dillo" {
\&                 Rule = "/Dillo: (.*)/\e\e1 [dillo]/"
\&         }
\&         Property = "^opera,^opera" {
\&                 Rule = "/...:... - (.*) - Opera .*/\e\e1 [opera]/"
\&         }
\& }
.Ve
.PP
.Vb 5
\& DecorRules {
\&         Property = "^.term,^XTerm" {
\&                 Decor = "TERM"
\&         }
\& }
.Ve
.PP
.Vb 5
\& Harbour {
\&         Property = "^obpager,^obpager" {
\&                 Position = "-1"
\&         }
\& }
.Ve
.Sp
.RS 4
Regular Expressions!
.Sp
The pekwm autoproperrties file uses Regular Expression syntax for
wildcards. Regular expressions can be really confusing to people with
no experience with them. A good rule of thumb is: \*(L"Anywhere you'd think
to use '*', use '.*'\*(R". Also, '^' matches the beginning of a string, '$'
matches the end, and '.' is any single character. Regular Expression
syntax is a little bit beyond the scope of this documentation. There's
a really basic tutorial at
http://www.living\-source.com/user/adi/regexp/regexp_tutorial.html, And
a slightly more advanced one at
http://www.zytrax.com/tech/web/regex.htm. You might also want to look
at http://www.regularexpressions.info/ I found these on google, using
the search phrase \*(L"regular.expression.tutorial\*(R". You can probably use
that search term or modify it to find some others.
.RE
.PP
\&\-\-\-\-
.Sh "10.3. Advanced Autoproperties"
.IX Subsection "10.3. Advanced Autoproperties"
Below is a list of the different actions available to you in your
autoproperties file; These are the actual Auto Properties. They can
take four types of arguments: bool, integer, string, or geom. A bool is
either True (1) or False (0). An Integer is a number, negative or
positive. A string is any string, it's used as an identifier. Finally,
geom is an X Geometry String by the form:
"[=][<width>{xX}<height>][{+\-}<xoffset>{+\-}<yoffset>]"
(see: man 3 XParseGeometry). Examples are 200x300+0+0, 0x500+200+300,
20x10+0+50, et cetera.
.PP
Exhaustive Autoprops List
.IP "Sticky (bool)" 4
.IX Item "Sticky (bool)"
Window Starts Sticky (present on all workspaces)
.IP "Shaded (bool)" 4
.IX Item "Shaded (bool)"
Window Starts Shaded
.IP "MaximizedVertical (bool)" 4
.IX Item "MaximizedVertical (bool)"
Window Starts Maximized Vertically
.IP "MaximizedHorizontal (bool)" 4
.IX Item "MaximizedHorizontal (bool)"
Window Starts Maximized Horizontally
.IP "Iconified (bool)" 4
.IX Item "Iconified (bool)"
Window Starts Iconified
.IP "Border (bool)" 4
.IX Item "Border (bool)"
Window Starts with a border
.IP "Titlebar (bool)" 4
.IX Item "Titlebar (bool)"
Window Starts with a TitleBar
.IP "ClientGeometry (geom)" 4
.IX Item "ClientGeometry (geom)"
X Geometry String showing the initial size and position of the client,
excluding the possible pekwm titlebar and window borders.
.IP "FrameGeometry (geom)" 4
.IX Item "FrameGeometry (geom)"
X Geometry String showing the initial size and position of the window
frame. Window frame includes the client window and the possible pekwm
titlebar and window borders. If both ClientGeometry and FrameGeometry
are present, FrameGeometry overrides the ClientGeometry.
.IP "Workspace (integer)" 4
.IX Item "Workspace (integer)"
Which workspace to start program on.
.IP "Viewport (integer) (integer)" 4
.IX Item "Viewport (integer) (integer)"
Which viewport to start program on. First integer is the column, second
the row of the viewport to open the window in.
.IP "PlaceNew (bool)" 4
.IX Item "PlaceNew (bool)"
Toggles the use of placing rules for this client.
.IP "FocusNew (bool)" 4
.IX Item "FocusNew (bool)"
Toggles if this client gets focused when it initially pops up a window.
.IP "Focusable (bool)" 4
.IX Item "Focusable (bool)"
Toggles if this client can be focused while it's running.
.IP "CfgDeny (string)" 4
.IX Item "CfgDeny (string)"
A list of conditions of when to deny things requested by the client
program, consisting of
.RS 4
.IP "*" 4
\&\*(L"Position\*(R" (Ignore client requested changes to window position)
.IP "*" 4
\&\*(L"Size\*(R" (Ignore client requested changes to window size)
.IP "*" 4
\&\*(L"Stacking\*(R" (Ignore client requested changes to window stacking)
.IP "*" 4
\&\*(L"ActiveWindow\*(R" (Ignore client requests for showing and giving input
focus)
.IP "*" 4
\&\*(L"MaximizedVert\*(R" (Ignore client request to maximize window vertically)
.IP "*" 4
\&\*(L"MaximizedHorz\*(R" (Ignore client request to maximize window horizontally)
.IP "*" 4
\&\*(L"Hidden\*(R" (Ignore client request to show/hide window)
.IP "*" 4
\&\*(L"Fullscreen\*(R" (Ignore client request to set window to fullscreen mode)
.IP "*" 4
\&\*(L"Above\*(R" (Ignore client request to always place window above other
windows)
.IP "*" 4
\&\*(L"Below\*(R" (Ignore client request to always place window below other
windows)
.RE
.RS 4
.RE
.IP "ApplyOn (string)" 4
.IX Item "ApplyOn (string)"
A list of conditions of when to apply this autoprop (so be sure to
include this in your property), consisting of
.RS 4
.IP "*" 4
\&\*(L"Start\*(R" (Apply if window already exists before pekwm starts/restarts.
Note when using grouping Start will not take workspaces in account)
.IP "*" 4
\&\*(L"Reload\*(R" (Apply when pekwm's config files are reloaded)
.IP "*" 4
\&\*(L"New\*(R" (Applies when the application first starts)
.IP "*" 4
\&\*(L"Workspace\*(R" (Apply when the window is sent to another workspace)
.IP "*" 4
\&\*(L"Transient\*(R" (Apply to Transient windows as well as normal windows.
Dialog boxes are commonly transient windows)
.IP "*" 4
\&\*(L"TransientOnly\*(R" (Apply to Transient windows only. Dialog boxes are
commonly transient windows)
.RE
.RS 4
.RE
.IP "Skip (string)" 4
.IX Item "Skip (string)"
A list of situations when to ignore the defined application and let the
user action skip over it, consisting of
.RS 4
.IP "*" 4
\&\*(L"Snap\*(R" (Do not snap to this window while moving windows)
.IP "*" 4
\&\*(L"Menus\*(R" (Do not show this window in pekwm menus other than the icon
menu)
.IP "*" 4
\&\*(L"FocusToggle\*(R" (Do not focus to this window when doing Next/PrevFrame)
.RE
.RS 4
.RE
.IP "Layer (string)" 4
.IX Item "Layer (string)"
Windows layer. Makes the window stay under or above other windows.
Default layer is \*(L"Normal\*(R". Possible parameters are (listed from the
bottommost to the uppermost):
.RS 4
.IP "*" 4
Desktop
.IP "*" 4
Below
.IP "*" 4
Normal
.IP "*" 4
OnTop
.IP "*" 4
Harbour
.IP "*" 4
AboveHarbour
.IP "*" 4
Menu
.RE
.RS 4
.RE
.IP "Title (string)" 4
.IX Item "Title (string)"
Apply this autoproperty on clients that have a title that matches this
string. String is a regexp like: \*(L"^Saving\*(R".
.IP "Role (string)" 4
.IX Item "Role (string)"
Apply this autoproperty on clients that have a \s-1WM_WINDOW_ROLE\s0 hint that
matches this string. String is a regexp like: \*(L"^Main\*(R".
.IP "Group (string)" 4
.IX Item "Group (string)"
Defines the name of the group. Also the section that contains all the
grouping options. They are:
.RS 4
.IP "*" 4
Size (integer) \- How many clients should be grouped in one group.
.IP "*" 4
Behind (bool) \- If true makes new clients of a group not to become the
active one in the group.
.IP "*" 4
Global (bool) \- If true makes new clients start in a group even if the
group is on another workspace or iconified.
.IP "*" 4
Raise (bool) \- If true makes new clients raise the frame they open in.
.IP "*" 4
FocusedFirst (bool) \- If true and there are more than one frame where
the window could be autogrouped into, the currently focused frame is
considered the first option.
.RE
.RS 4
.RE
.PP
\&\-\-\-\-
.Sh "10.4. AutoGrouping"
.IX Subsection "10.4. AutoGrouping"
The last thing to know is autogrouping. Autogrouping is actually very
simple, although it might be a bit confusing at first. Group is an
identifier, itE<acute>s just a string, (in my example, we'll call it
netwin). Size tells how many clients to group together in one frame.
.PP
The example: We want to autogroup Sylpheed and Opera together, allowing
as many instances of the program windows to be grouped as there are.
Here's the Autoprops section for that:
.PP
.Vb 12
\& Property = ".*,^opera" {
\&         Group = "netwin" {
\&                 Size = "0"
\&         }
\&         ApplyOn = "New Start Reload"
\& }
\& Property = ".*,^Sylpheed" {
\&         Group = "netwin" {
\&                 Size = "0"
\&         }
\&         ApplyOn = "New Start Reload Transient"
\& }
.Ve
.PP
This creates two rules: \*(L"For any window matching '.*,^opera', group
these in the 'netwin' group. Apply this on pekwm start/reload and when
new windows matching this property are opened, but do not include
dialog windows\*(R", and \*(L"For any window matching '.*,^Sylpheed', group in
the 'netwin' group. Apply on pekwm start/reload and when new windows
matching this property are opened, also include possible dialog windows
to the group. Open the window to the group but do not bring it upmost
automatically\*(R".
.PP
To group unlimited windows together, use size 0.
.PP
Also note that you can have as many Group identifiers as you want.
Autogrouping is a very flexible system. Try playing around with it.
.PP
\&\-\-\-\-
.Sh "10.5. Getting more help"
.IX Subsection "10.5. Getting more help"
Autoprops can be a daunting topic. If you've read everything here in
the docs and are still having problems, feel free to hit the \s-1IRC\s0
channel and ask. Check the Common questions and answers before asking.
Remember that: \*(L"\s-1IF\s0 \s-1YOU\s0 \s-1WANT\s0 \s-1AN\s0 \s-1ANSWER\s0 \s-1TO\s0 \s-1YOUR\s0 \s-1QUESTION\s0, \s-1YOU\s0 \s-1HAD\s0 \s-1BETTER\s0
\&\s-1HAVE\s0 \s-1ALREADY\s0 \s-1READ\s0 \s-1THE\s0 \s-1DOCUMENTATION\s0\*(R".
.PP
\&\-\-\-\-
.SH "Chapter 11. Keyboard and Mouse Configuration"
.IX Header "Chapter 11. Keyboard and Mouse Configuration"
Pekwm allows you to remap almoust all keyboard and mouse events.
.PP
\&\-\-\-\-
.Sh "11.1. Mouse Bindings"
.IX Subsection "11.1. Mouse Bindings"
The pekwm Mousebindings go in \f(CW\*(C`~/.pekwm/mouse\*(C'\fR, and are very simple.
They're divided up into two groups: The 'where' and 'event'. Below is
an example file:
.PP
.Vb 16
\& FrameTitle {
\&         ButtonRelease = "1" { Actions = "Raise; Focus; ActivateClient" }
\&         ButtonRelease = "2" { Actions = "ActivateClient" }
\&         ButtonRelease = "Mod4 3" { Actions = "Close" }
\&         ButtonRelease = "3" { Actions = "ShowMenu Window" }
\&         ButtonRelease = "4" { Actions = "ActivateClientRel 1" }
\&         ButtonRelease = "5" { Actions = "ActivateClientRel -1" }
\&         DoubleClick = "2" { Actions = "Toggle Shaded" }
\&         DoubleClick = "1" { Actions = "MaxFill True True" }
\&         Motion = "1" { Threshold = "4"; Actions = "Move" }
\&         Motion = "Mod1 1" { Threshold = "4"; Actions = "Move" }
\&         Motion = "Mod4 1" { Threshold = "4"; Actions = "Move" }
\&         Motion = "2" { Threshold = "4"; Actions = "GroupingDrag True" }
\&         Motion = "Mod1 3" { Actions = "Resize" }
\&         Enter = "Any Any" { Actions = "Focus" }
\& }
.Ve
.PP
.Vb 11
\& OtherTitle {
\&         ButtonRelease = "1" { Actions = "Raise; Focus; ActivateClient" }
\&         ButtonRelease = "Mod4 3" { Actions = "Close" }
\&         DoubleClick = "2" { Actions = "Toggle Shaded" }
\&         DoubleClick = "1" { Actions = "MaxFill True True" }
\&         Motion = "1" { Threshold = "4"; Actions = "Move" }
\&         Motion = "Mod1 1" { Threshold = "4"; Actions = "Move" }
\&         Motion = "Mod4 1" { Threshold = "4"; Actions = "Move" }
\&         Motion = "Mod1 3" { Actions = "Resize" }
\&         Enter = "Any Any" { Actions = "Focus" }
\& }
.Ve
.PP
.Vb 10
\& Border {
\&         TopLeft     { Enter = "Any Any" { Actions = "Focus" }; ButtonPress = "1" { Actions = "Resize TopLeft" } }
\&         Top         { Enter = "Any Any" { Actions = "Focus" }; ButtonPress = "1" { Actions = "Move" } }
\&         TopRight    { Enter = "Any Any" { Actions = "Focus" }; ButtonPress = "1" { Actions = "Resize TopRight" } }
\&         Left        { Enter = "Any Any" { Actions = "Focus" }; ButtonPress = "1" { Actions = "Resize Left" } }
\&         Right       { Enter = "Any Any" { Actions = "Focus" }; ButtonPress = "1" { Actions = "Resize Right" } }
\&         BottomLeft  { Enter = "Any Any" { Actions = "Focus" }; ButtonPress = "1" { Actions = "Resize BottomLeft" } }
\&         Bottom      { Enter = "Any Any" { Actions = "Focus" }; ButtonPress = "1" { Actions = "Resize Bottom" } }
\&         BottomRight { Enter = "Any Any" { Actions = "Focus" }; ButtonPress = "1" { Actions = "Resize BottomRight" } }
\& }
.Ve
.PP
.Vb 44
\& ScreenEdge {
\&         Down {
\&                 Enter = "Mod4 Any" { Actions = "ViewportMoveDirection Down" }
\&                 ButtonRelease = "3" { Actions = "ShowMenu Root" }
\&                 ButtonRelease = "Mod4 1" { Actions = "ViewportMoveDirection Down" }
\&                 ButtonRelease = "2" { Actions = "ShowMenu Goto" }
\&                 EnterMoving = "Mod4 Any" { Actions = "WarpToViewport Down" }
\&         }
\&         Up {
\&                 Enter = "Mod4 Any" { Actions = "ViewportMoveDirection Up" }
\&                 ButtonRelease = "3" { Actions = "ShowMenu Root" }
\&                 ButtonRelease = "Mod4 1" { Actions = "ViewportMoveDirection Up" }
\&                 ButtonRelease = "2" { Actions = "ShowMenu Goto" }
\&                 ButtonRelease = "Mod1 4" { Actions = "GoToWorkspace Right" }
\&                 ButtonRelease = "Mod1 5" { Actions = "GoToWorkspace Left" }
\&                 EnterMoving = "Mod4 Any" { Actions = "WarpToViewport Up" }
\&         }
\&         Left {
\&                 Enter = "Mod1 Any" { Actions = "GoToWorkspace Left" }
\&                 Enter = "Mod4 Any" { Actions = "ViewportMoveDirection Left" }
\&                 ButtonRelease = "3" { Actions = "ShowMenu Root" }
\&                 ButtonRelease = "Mod4 1" { Actions = "ViewportMoveDirection Left" }
\&                 ButtonRelease = "1" { Actions = "GoToWorkspace Left" }
\&                 DoubleClick = "1" { Actions = "GoToWorkspace Left" }
\&                 ButtonRelease = "2" { Actions = "ShowMenu Goto" }
\&                 ButtonRelease = "4" { Actions = "GoToWorkspace Right" }
\&                 ButtonRelease = "5" { Actions = "GoToWorkspace Left" }
\&                 EnterMoving = "Mod4 Any" { Actions = "WarpToViewport Left" }
\&                 EnterMoving = "Any Any" { Actions = "WarpToWorkspace Left" }
\&         }
\&         Right {
\&                 Enter = "Mod1 Any" { Actions = "GoToWorkspace Right" }
\&                 Enter = "Mod4 Any" { Actions = "ViewportMoveDirection Right" }
\&                 ButtonRelease = "3" { Actions = "ShowMenu Root" }
\&                 ButtonRelease = "Mod4 1" { Actions = "ViewportMoveDirection Right" }
\&                 ButtonRelease = "1" { Actions = "GoToWorkspace Right" }
\&                 DoubleClick = "1" { Actions = "GoToWorkspace Right" }
\&                 ButtonRelease = "2" { Actions = "ShowMenu Goto" }
\&                 ButtonRelease = "4" { Actions = "GoToWorkspace Right" }
\&                 ButtonRelease = "5" { Actions = "GoToWorkspace Left" }
\&                 EnterMoving = "Mod4 Any" { Actions = "WarpToViewport Right" }
\&                 EnterMoving = "Any Any" { Actions = "WarpToWorkspace Right" }
\&         }
\& }
.Ve
.PP
.Vb 10
\& Client {
\&         ButtonPress = "1" { Actions = "Focus" }
\&         ButtonRelease = "Mod1 1" { Actions = "Focus; Raise" }
\&         ButtonRelease = "Mod4 1" { Actions = "Lower" }
\&         Motion = "Mod1 1" { Actions = "Focus; Raise; Move" }
\&         Motion = "Mod4 1" { Actions = "Focus; Raise; Move" }
\&         Motion = "Mod1 2" { Threshold = "4"; Actions = "GroupingDrag True" }
\&         Motion = "Mod1 3" { Actions = "Resize" }
\&         Enter = "Any Any" { Actions = "Focus" }
\& }
.Ve
.PP
.Vb 8
\& Root {
\&         ButtonRelease = "3" { Actions = "ShowMenu Root" }
\&         ButtonRelease = "2" { Actions = "ShowMenu Goto" }
\&         ButtonRelease = "4" { Actions = "GoToWorkspace Right" }
\&         ButtonRelease = "5" { Actions = "GoToWorkspace Left" }
\&         ButtonRelease = "1" { Actions = "HideAllMenus" }
\&         Motion = "1" { Threshold = "10"; Actions = "ViewportMoveDrag" }
\& }
.Ve
.PP
.Vb 6
\& Menu {
\&         Enter = "Any Any" { Actions = "Focus" }
\&         ButtonRelease = "2" { Actions = "Toggle Sticky" }
\&         Motion = "1" { Threshold = "10"; Actions = "Move" }
\&         ButtonRelease = "3" { Actions = "Close" }
\& }
.Ve
.PP
.Vb 6
\& Other {
\&         Enter = "Any Any" { Actions = "Focus" }
\&         ButtonRelease = "Mod4 3" { Actions = "Close" }
\&         Motion = "1" { Actions = "Focus; Raise; Move" }
\&         Motion = "Mod1 1" { Actions = "Focus; Raise; Move" }
\& }
.Ve
.PP
Below are defined the different fields. The actions themselves can be
found in the Keys/mouse actions section.
.PP
\&'Where' fields:
.IP "FrameTitle" 4
.IX Item "FrameTitle"
On a regular window's Titlebar.
.IP "OtherTitle" 4
.IX Item "OtherTitle"
On menu/cmdDialog/etc pekwm's own window's Titlebar.
.IP "Border" 4
.IX Item "Border"
On the window's borders. See Border Subsection for more information.
.IP "ScreenEdge" 4
.IX Item "ScreenEdge"
On the screen edges. See ScreenEdge Subsection for more information.
.IP "Client" 4
.IX Item "Client"
Anywhere on the window's interiour\- it's best to use a keyboard
modifier with these.
.IP "Root" 4
.IX Item "Root"
On the Root window (also called the 'desktop').
.IP "Menu" 4
.IX Item "Menu"
On the various menus excluding their titlebars.
.IP "Other" 4
.IX Item "Other"
On everything else that doesn't have it's own section.
.PP
\&'Event' fields:
.IP "ButtonPress" 4
.IX Item "ButtonPress"
A single click
.IP "ButtonRelease" 4
.IX Item "ButtonRelease"
A single click that activates once the button is released
.IP "DoubleClick" 4
.IX Item "DoubleClick"
A double click
.IP "Motion" 4
.IX Item "Motion"
Clicking, holding, and Dragging.
.IP "Enter" 4
.IX Item "Enter"
Defines how to act when mouse pointer enters a place defined by the
\&'where' field.
.IP "Leave" 4
.IX Item "Leave"
Defines how to act when mouse pointer leaves a place defined by the
\&'where' field.
.IP "EnterMoving" 4
.IX Item "EnterMoving"
Defines how to act when a dragged window enters a ScreenEdge. Only
works with screen edges.
.PP
Definitions work like this:
.PP
.Vb 8
\& 'Where' {
\&         'Event' = "optional modifiers, like mod1, ctrl, etc and a mouse button" {
\&                 Actions = "actions and their parameters"
\&         }
\&         'Event' = "optional modifiers, like mod1, ctrl, etc and a mouse button" {
\&                 Actions = "actions and their parameters"
\&         }
\& }
.Ve
.Sp
.RS 4
Additional notes.
.Sp
Modifiers and mouse buttons can be defined as \*(L"Any\*(R" which is useful for
Enter and Leave events. Any also applies as none. Motion events have a
threshold argument. This is the number of pixels you must drag your
mouse before they begin to work. Multiple actions can be defined for a
single user action. Example:
.RE
.PP
.Vb 2
\& Motion = "1" { Actions = "Move"; Treshold = "3" }
\& ButtonPress = "1" { Actions = "Raise; ActivateClient" }
.Ve
.PP
\&\-\-\-\-
.Sh "11.2. Border Subsection"
.IX Subsection "11.2. Border Subsection"
The Border subsection in \f(CW\*(C`~/.pekwm/mouse\*(C'\fR defines the actions to take
when handling the window borders.
.PP
.Vb 6
\& Border {
\&         TopLeft {
\&                 Enter = "Any Any" { Actions = "Focus" }
\&                 ButtonPress = "1" { Actions = "Resize TopLeft" }
\&         }
\& }
.Ve
.PP
ItE<acute>s subsections refer to the frame part in question. They are:
Top, Bottom, Left, Right, TopLeft, TopRight, BottomLeft, and
BottomRight. In these subsections you can define events and actions as
usual.
.PP
\&\-\-\-\-
.Sh "11.3. ScreenEdge Subsection"
.IX Subsection "11.3. ScreenEdge Subsection"
The ScreenEdge subsection in \f(CW\*(C`~/.pekwm/mouse\*(C'\fR defines the actions to
take when an event happens on the specified screenedge.
.PP
.Vb 14
\& ScreenEdge {
\&         Left {
\&                 Enter = "Mod1 Any" { Actions = "GoToWorkspace Left" }
\&                 Enter = "Mod4 Any" { Actions = "ViewportMoveDirection Left" }
\&                 ButtonPress = "3" { Actions = "ShowMenu Root" }
\&                 ButtonPress = "Mod4 1" { Actions = "ViewportMoveDirection Left" }
\&                 ButtonPress = "1" { Actions = "GoToWorkspace Left" }
\&                 ButtonPress = "2" { Actions = "ShowMenu Goto" }
\&                 ButtonPress = "4" { Actions = "GoToWorkspace Right" }
\&                 ButtonPress = "5" { Actions = "GoToWorkspace Left" }
\&                 EnterMoving = "Mod4 Any" { Actions = "WarpToViewport Left" }
\&                 EnterMoving = "Any Any" { Actions = "WarpToWorkspace Left" }
\&         }
\& }
.Ve
.PP
It has four subsections: Up, Down, Left, and Right, that all refer to
the screen edge in question. In these subsections you can give events
and actions as usual.
.PP
\&\-\-\-\-
.Sh "11.4. Key Bindings"
.IX Subsection "11.4. Key Bindings"
The pekwm keybindings go in \f(CW\*(C`~/.pekwm/keys\*(C'\fR, and are even more simple
than the mouse bindings. Here's the format:
.PP
.Vb 3
\& KeyPress = "optional modifiers like mod1, ctrl, etc and the key" {
\&         Actions = "action and the parameters for the action, if they are needed"
\& }
.Ve
.PP
Multiple actions can be given for one keypress. The actions are
separated from eachother with a semicolon:
.PP
.Vb 1
\& Keypress = "Ctrl t" { Actions = "Exec xterm; Set Maximized True True; Close" }
.Ve
.PP
Here's a small fragment of an example keys file; you can see a full
version in \f(CW\*(C`~/.pekwm/keys\*(C'\fR. As with the mouse, you can see the full
list of actions in the Keys/mouse actions section.
.PP
.Vb 19
\& Global {
\&         # Moving in frames
\&         KeyPress = "Mod1 Tab" { Actions = "NextFrame EndRaise" }
\&         KeyPress = "Mod1 Shift Tab" { Actions = "PrevFrame EndRaise" }
\&         KeyPress = "Mod1 Ctrl Tab" { Actions = "NextFrameMRU EndRaise" }
\&         KeyPress = "Mod1 Ctrl Shift Tab" { Actions = "PrevFrameMRU EndRaise" }
\&         # Simple window management
\&         KeyPress = "Mod4 M" { Actions = "Toggle Maximized True True" }
\&         KeyPress = "Mod4 G" { Actions = "Maxfill True True" }
\&         KeyPress = "Mod4 F" { Actions = "Toggle FullScreen" }
\&         KeyPress = "Mod4 Return" { Actions = "MoveResize" }
\&         # Wm actions
\&         Chain = "Ctrl Mod1 P" {
\&                 KeyPress = "Delete" { Actions = "Reload" }
\&                 KeyPress = "Next" { Actions = "Restart" }
\&                 KeyPress = "End" { Actions = "Exit" }
\&                 KeyPress = "Prev" { Actions = "RestartOther twm" }
\&         }
\& }
.Ve
.PP
.Vb 13
\& MoveResize {
\&         KeyPress = "Left" { Actions = "MoveHorizontal -10" }
\&         KeyPress = "Right" { Actions = "MoveHorizontal 10" }
\&         KeyPress = "Up" { Actions = "MoveVertical -10" }
\&         KeyPress = "Down" { Actions = "MoveVertical 10" }
\&         Keypress = "Mod4 Left" { Actions = "ResizeHorizontal -10" }
\&         Keypress = "Mod4 Right" { Actions = "ResizeHorizontal 10" }
\&         Keypress = "Mod4 Up" { Actions = "ResizeVertical -10" }
\&         Keypress = "Mod4 Down" { Actions = "ResizeVertical 10" }
\&         Keypress = "s" { Actions = "MoveSnap" }
\&         Keypress = "Escape" { Actions = "Cancel" }
\&         Keypress = "Return" { Actions = "End" }
\& }
.Ve
.PP
.Vb 8
\& Menu {
\&         KeyPress = "Down" { Actions = "NextItem" }
\&         KeyPress = "Up" { Actions = "PrevItem" }
\&         KeyPress = "Left" { Actions = "LeaveSubmenu" }
\&         KeyPress = "Right" { Actions = "EnterSubmenu" }
\&         KeyPress = "Return" { Actions = "Select" }
\&         KeyPress = "Escape" { Actions = "Close" }
\& }
.Ve
.PP
.Vb 11
\& CmdDialog {
\&         KeyPress = "BackSpace" { Actions = "Erase" }
\&         KeyPress = "Right" { Actions = "CursNext" }
\&         KeyPress = "Left" { Actions = "CursPrev" }
\&         KeyPress = "Up" { Actions = "HistPrev" }
\&         KeyPress = "Down" { Actions = "HistNext" }
\&         KeyPress = "Delete" { Actions = "Clear" }
\&         KeyPress = "Return" { Actions = "Exec" }
\&         KeyPress = "Escape" { Actions = "Close" }
\&         KeyPress = "Any Any" { Actions = "Insert" }
\& }
.Ve
.PP
As you might have noticed, the file consist of four sections. These
sections are Global, MoveResize, Menu and CmdDialog. The first section,
Global, contains all the generic actions.
.PP
The MoveResize section has the keybindings that will get used when the
MoveResize action is called.
.PP
Menu section contains the keys that are used when the ShowMenu action
is called. E.g. these are the keys you use to browse thru the menus of
pekwm. Note that while ShowMenu is active, the Global keybindings are
also listened. If a keybinding is same in both Menu and Global
sections, keybindings in Menu section override the global keybinding as
long as a menu is active.
.PP
Finally, the CmdDialog section allow for tuning of what keys are
available for line editing when the CmdDialog window that enables the
user to enter pekwm actions for running windows is active.
.PP
Keys can be identified with their XString name or with their keycode.
Both can be found out using the X application \fBxev\fR. If you want to
use a keycode, prefix it with \fB#\fR.
.PP
\&\-\-\-\-
.Sh "11.5. Keychains"
.IX Subsection "11.5. Keychains"
Pekwm also supports keychains. Keychain syntax follows the general
config syntax and looks like this:
.PP
.Vb 6
\& Chain = "modifiers and key" {
\&         Chain = "modifiers and key" {
\&                 KeyPress = "modifiers and key" { Actions = "actions and their parameters" }
\&         }
\&         Keypress = "modifiers and key" { Actions = "actions and their parameters" }
\& }
.Ve
.PP
It might seem complicated at start but once you look into it, it is
fairly nice and logical. This syntax supports as many nested Chains as
you might want.
.PP
Now for some examples. Here we have a simple nested chain that lets you
press Ctrl+Alt+M, then M, then M, V or H to toggle maximized attribute
into Full/Vertical or Horizontal, and a simpler one level chain that
brings up the root menu.
.PP
.Vb 10
\& Chain = "Ctrl Mod1 A" {
\&         Chain = "M" {
\&                 KeyPress = "M" { Actions = "Toggle Maximized True True" }
\&                 KeyPress = "V" { Actions = "Toggle Maximized False True" }
\&                 KeyPress = "H" { Actions = "Toggle Maximized True False" }
\&         }
\& }
\& Chain = "Ctrl Mod1 M" {
\&         KeyPress = "R" { Actions = "ShowMenu Root" }
\& }
.Ve
.PP
This next rule is a pure show\-off, it lets you type in 'test' and then
executes xterm. Note that this will make you unable to type the
character 't' to any programs.
.PP
.Vb 3
\& Chain = "t" { Chain = "e" { Chain = "s" {
\&         Keypress = "t" { Actions = "Exec xterm" }
\& } } }
.Ve
.PP
\&\-\-\-\-
.Sh "11.6. Keys/Mouse actions and window attributes"
.IX Subsection "11.6. Keys/Mouse actions and window attributes"
Here is the list of all possible actions and attributes. First table
shows all toggleable attributes. Toggleable attributes are controlled
using the \fISet\fR, \fIUnset\fR and \fIToggle\fR actions. Examples below.
.PP
.Vb 4
\& Keypress = "Mod4 s"       { Actions = "Toggle Shaded" }
\& Keypress = "Mod4 m"       { Actions = "Toggle Maximized True True" }
\& Keypress = "Mod4 t"       { Actions = "Set Tagged" }
\& Keypress = "Mod4 Shift t" { Actions = "Unset Tagged" }
.Ve
.PP
Toggleable attributes:
.IP "Maximized (bool bool)" 4
.IX Item "Maximized (bool bool)"
If a frame is maximized. Two parameters, first one decides if the frame
is maximized horizontally, the second if it is maximized vertically.
.IP "Shaded" 4
.IX Item "Shaded"
If a frame should be shaded (so that only the titlebar shows until it's
unset or toggled off).
.IP "Iconified" 4
.IX Item "Iconified"
If a frame should be iconified.
.IP "Sticky" 4
.IX Item "Sticky"
If a frame should be sticky so it appears on every workspace.
.IP "AlwaysOnTop" 4
.IX Item "AlwaysOnTop"
If frame should allways be on top of other frames.
.IP "AlwaysBelow" 4
.IX Item "AlwaysBelow"
If a frame should allways be below other frames.
.IP "DecorBorder" 4
.IX Item "DecorBorder"
If frame should have borders.
.IP "DecorTitlebar" 4
.IX Item "DecorTitlebar"
If frame should have a titlebar.
.IP "Fullscreen" 4
.IX Item "Fullscreen"
If a frame should be fullscreen. Fullscreen frame takes over the whole
desktop ignoring any harbour or struts and becomes decorless.
.IP "Marked" 4
.IX Item "Marked"
If a frame is marked for later attaching (with AttachMarked).
.IP "Tagged (bool)" 4
.IX Item "Tagged (bool)"
If a frame should swallow all new clients until unset or toggled off.
One parameter, if true new clients open in the background. Defaults to
false.
.IP "Skip (string)" 4
.IX Item "Skip (string)"
If a frame should be ignored on specified places, string is one of
.RS 4
.IP "*" 4
menus
.IP "*" 4
focustoggle
.IP "*" 4
snap
.RE
.RS 4
.RE
.IP "Title (string)" 4
.IX Item "Title (string)"
Changes the clients titlebar text to string when set. Unsetting returns
the clients title text back to the client specified one.
.IP "CfgDeny (string)" 4
.IX Item "CfgDeny (string)"
When things to be done to this window requested by the client program
should be denied, string is one of:
.RS 4
.IP "*" 4
position (don't let the client move the window)
.IP "*" 4
size (don't let the client resize the window)
.IP "*" 4
stacking (don't allow the client to raise or lower the window)
.IP "*" 4
activewindow (don't let client give input focus)
.IP "*" 4
maximizedvert (don't let client maximize a window vertically)
.IP "*" 4
maximizedhorz (don't let client maximize window horizontally)
.IP "*" 4
hidden (don't let client hide window)
.IP "*" 4
fullscreen (don't let client set window fullscreen mode)
.IP "*" 4
above (don't let client place window above other windows)
.IP "*" 4
below (don't let client place window below other windows)
.RE
.RS 4
.RE
.IP "GlobalGrouping" 4
.IX Item "GlobalGrouping"
If all autogrouping should be in use or not. By default it's set, as in
autogrouping is enabled.
.PP
Keys/Mouse Actions:
.IP "Set (one of toggleable attributes)" 4
.IX Item "Set (one of toggleable attributes)"
Makes toggleable attributes set.
.IP "UnSet (one of toggleable attributes)" 4
.IX Item "UnSet (one of toggleable attributes)"
Unsets toggleable attributes.
.IP "Toggle (one of toggleable attributes)" 4
.IX Item "Toggle (one of toggleable attributes)"
Toggles toggleable attributes.
.IP "MaxFill (bool bool)" 4
.IX Item "MaxFill (bool bool)"
Acts much like Maximize, but considers other frames while doing it.
Instead of filling the whole screen, it only gvarlistentrys to hit the
borders of neighboring frames. Takes two parameters, first one decides
if the frame is maxfilled horizontally, the second if it should be
maxfilled vertically.
.IP "Close" 4
.IX Item "Close"
Closes a client window.
.IP "CloseFrame" 4
.IX Item "CloseFrame"
Closes a frame and all client windows in it.
.IP "Kill" 4
.IX Item "Kill"
Kills a client window, use if close doesn't work.
.IP "Raise (bool)" 4
.IX Item "Raise (bool)"
Raises a frame above other frames. If bool is true raises a frame and
all of the currently active clients child/parent windows above other
frames.
.IP "ActivateOrRaise" 4
.IX Item "ActivateOrRaise"
If the frame this action is used on is not focused, focuses it. If the
frame is focused, raises it. If used on a groups titlebar, activates
the selected client of the group.
.IP "Lower (bool)" 4
.IX Item "Lower (bool)"
Lowers a frame under other frames. If bool is true lowers a frame and
all of the currently active clients child/parent windows under other
frames.
.IP "ActivateClientRel (int)" 4
.IX Item "ActivateClientRel (int)"
Moves the focus and raises a client inside a frame relative to the
currently selected client. Int is 1 to move right, \-1 to move left.
.IP "MoveClientRel (int)" 4
.IX Item "MoveClientRel (int)"
Moves the current clients position inside the current frame. Int is 1
to move right, \-1 to move left.
.IP "ShowMenu (string bool)" 4
.IX Item "ShowMenu (string bool)"
Shows a menu. String is menu type:
.RS 4
.IP "*" 4
root \- shows your application menu
.IP "*" 4
icon \- shows iconified windows
.IP "*" 4
goto \- shows currently active clients
.IP "*" 4
gotoclient \- shows all open clients
.IP "*" 4
window \- shows a window specific menu
.IP "*" 4
decor \- shows possible decorations in the current theme
.IP "*" 4
attachclient \- allows to attach clients in current frame
.IP "*" 4
attachframe \- allows to attach whole frame in current frame
.IP "*" 4
attachclientinframe \- allows attaching current clent in any other frame
.IP "*" 4
attachframeinframe \- allows attaching current frame in any other frame
.RE
.RS 4
.Sp
Bool is true for sticky menus, false for click to vanish. Defaults to
false.
.RE
.IP "ShowCmdDialog" 4
.IX Item "ShowCmdDialog"
Shows the command dialog that can be used to input pekwm actions. If
it's a window specific action, it affects the window focused when
CmdDialog was summoned. If entered action doesn't match any valid pekwm
action, pekwm tries to Exec it as a shell command.
.IP "HideAllMenus" 4
.IX Item "HideAllMenus"
Closes all pekwm menus.
.IP "AttachMarked" 4
.IX Item "AttachMarked"
Attachs all marked clients to the current frame.
.IP "AttachClientInNextFrame" 4
.IX Item "AttachClientInNextFrame"
Attachs client to the next frame.
.IP "AttachClientInPrevFrame" 4
.IX Item "AttachClientInPrevFrame"
Attachs client to the previous frame.
.IP "AttachFrameInNextFrame" 4
.IX Item "AttachFrameInNextFrame"
Attachs frame to the next frame.
.IP "AttachFrameInPrevFrame" 4
.IX Item "AttachFrameInPrevFrame"
Attachs frame to the previous frame.
.IP "Detach" 4
.IX Item "Detach"
Detach the current client from its frame.
.IP "FindClient (string)" 4
.IX Item "FindClient (string)"
Searches the client list for a client that has a title matching the
given regex string.
.IP "Exec (string)" 4
.IX Item "Exec (string)"
Executes a program, string is a path to an executable file.
.IP "FocusDirectional (string bool)" 4
.IX Item "FocusDirectional (string bool)"
Focuses the first window on the direction specified, and optionally
raises it. Takes two options, first one is the direction and the second
specifies if the focused frame should be raised or not. Bool defaults
to True. String is one of up, down, left, right
.IP "ActivateClientNum (int)" 4
.IX Item "ActivateClientNum (int)"
Activates the #th client of a frame. Int is the client number counting
from left.
.Sp
Keygrabber-specific
.IP "MoveResize" 4
.IX Item "MoveResize"
Activates the keyboard move and resize.
.Sp
Keygrabber-specific
.IP "MoveToEdge (string)" 4
.IX Item "MoveToEdge (string)"
Moves the frame to the specified place on the screen. String is one of
TopLeft, TopEdge, TopRight, RightEdge, BottomRight, BottomEdge,
BottomLeft, LeftEdge, Center, TopCenterEdge, BottomCenterEdge,
LeftCenterEdge, RightCenterEdge.
.Sp
Keygrabber-specific
.IP "NextFrame (string)" 4
.IX Item "NextFrame (string)"
Focuses the next frame. String is one of:
.RS 4
.IP "*" 4
alwaysraise \- raise windows while toggling them
.IP "*" 4
endraise \- raise the selected client
.IP "*" 4
neverraise \- do not raise the selected client
.RE
.RS 4
.RE
.IP "PrevFrame (string)" 4
.IX Item "PrevFrame (string)"
Focuses the previous frame. String is:
.RS 4
.IP "*" 4
alwaysraise \- raise windows while toggling them
.IP "*" 4
endraise \- raise the selected client
.IP "*" 4
neverraise \- do not raise the selected client
.RE
.RS 4
.RE
.IP "NextFrameMRU (string)" 4
.IX Item "NextFrameMRU (string)"
Focuses the next frame so that the last focused windows will get
switched to first. String is:
.RS 4
.IP "*" 4
alwaysraise \- raise windows while toggling them
.IP "*" 4
endraise \- raise the selected client
.IP "*" 4
neverraise \- do not raise the selected client
.RE
.RS 4
.RE
.IP "PrevFrameMRU (string)" 4
.IX Item "PrevFrameMRU (string)"
Focuses the previous frame so that the last focused windows will get
switched to first. String is:
.RS 4
.IP "*" 4
alwaysraise \- raise windows while toggling them
.IP "*" 4
endraise \- raise the selected client
.IP "*" 4
neverraise \- do not raise the selected client
.RE
.RS 4
.RE
.IP "GotoWorkspace (string)" 4
.IX Item "GotoWorkspace (string)"
Changes workspaces. String is one of:
.RS 4
.IP "*" 4
next \- go to the next workspace, if on last workspace, wrap to the
first one.
.IP "*" 4
prev \- go to the previous workspace, if on first workspace, wrap to the
last one.
.IP "*" 4
left \- go to the previous workspace
.IP "*" 4
right \- go to the next workspace
.IP "*" 4
int \- integer is a workspace number to go to
.RE
.RS 4
.RE
.IP "GrowDirection (string)" 4
.IX Item "GrowDirection (string)"
Grows the frame in one of the directions up to the edge of the head.
String is one of up, down, left, right.
.IP "SendToWorkspace (string)" 4
.IX Item "SendToWorkspace (string)"
Sends a frame to the specified workspace. String is one of:
.RS 4
.IP "*" 4
next \- send to the next workspace, if on last workspace, wrap to the
first one.
.IP "*" 4
prev \- send to the previous workspace, if on first workspace, wrap to
the last one.
.IP "*" 4
left \- send to the previous workspace
.IP "*" 4
right \- send to the next workspace
.IP "*" 4
int \- integer is a workspace number to send to to
.RE
.RS 4
.RE
.IP "Reload" 4
.IX Item "Reload"
Reloads pekwm configs.
.Sp
Keygrabber-specific
.IP "Restart" 4
.IX Item "Restart"
Restarts pekwm.
.Sp
Keygrabber-specific
.IP "RestartOther" 4
.IX Item "RestartOther"
Quits pekwm and starts the program you specify. String is a path to an
executable file.
.Sp
Keygrabber-specific
.IP "Exit" 4
.IX Item "Exit"
Exits pekwm.
.Sp
Keygrabber-specific
.IP "ViewportMoveXY (int int)" 4
.IX Item "ViewportMoveXY (int int)"
Move viewport view to wanted coordinates. Takes two parameters, first
is x, the second y.
.IP "ViewportScroll (int int)" 4
.IX Item "ViewportScroll (int int)"
Move viewport this many pixels. Parameters can be negative or positive
integers. First integer is x, second y.
.IP "ViewportGoto (int int)" 4
.IX Item "ViewportGoto (int int)"
Change viewport. Two parameters, first integer is the column, second
the varlistentry.
.IP "ViewportMoveDirection (string)" 4
.IX Item "ViewportMoveDirection (string)"
Changes the current viewport position. String is one of up, down, left,
right
.IP "ViewportMoveDrag" 4
.IX Item "ViewportMoveDrag"
Changes the current viewport position.
.Sp
Root window-specific mouse binding
.IP "Resize (string)" 4
.IX Item "Resize (string)"
Resizes a frame. String is one of top, bottom, left, right, topleft,
topright, bottomleft, bottomright.
.Sp
Mouse-specific (parameters frameborder\-specific)
.IP "Move" 4
.IX Item "Move"
Moves a frame.
.Sp
Mouse-specific
.IP "ActivateClient" 4
.IX Item "ActivateClient"
Activates a client of a frame.
.Sp
Mouse-specific
.IP "Focus" 4
.IX Item "Focus"
Gives focus to a frame.
.Sp
Mouse-specific
.IP "UnFocus" 4
.IX Item "UnFocus"
Removes focus from a frame.
.Sp
Mouse-specific
.IP "GroupingDrag (bool)" 4
.IX Item "GroupingDrag (bool)"
Drags windows in and out of frames, if parameter is true dragged
windows go in the background of a frame.
.Sp
Mouse-specific
.IP "WarpToWorkspace (string)" 4
.IX Item "WarpToWorkspace (string)"
Makes a dragged window warp to specified workspace when a it's moved
over a screen edge. String is one:
.RS 4
.IP "*" 4
next \- send to the next workspace, if on last workspace, wrap to the
first one.
.IP "*" 4
prev \- send to the previous workspace, if on first workspace, wrap to
the last one.
.IP "*" 4
left \- send to the previous workspace
.IP "*" 4
right \- send to the next workspace
.IP "*" 4
int \- integer is a workspace number to send to to
.RE
.RS 4
.Sp
ScreenEdge specific mouse binding
.RE
.IP "WarpToViewport (string)" 4
.IX Item "WarpToViewport (string)"
Makes a dragged window warp to specified viewport when a it's moved
over a screen edge. String is one of up, down, left, right
.Sp
ScreenEdge specific mouse binding
.IP "MoveHorizontal (int)" 4
.IX Item "MoveHorizontal (int)"
Moves a frame horizontally. Int is amount of pixels and can be
negative.
.Sp
Moveresize-specific keybinding
.IP "MoveVertical (int)" 4
.IX Item "MoveVertical (int)"
Moves a frame vertically. Int is amount of pixels and can be negative.
.Sp
Moveresize-specific keybinding
.IP "ResizeHorizontal (int)" 4
.IX Item "ResizeHorizontal (int)"
Resizes a frame horizontally. Int is amount of pixels and can be
negative.
.Sp
Moveresize-specific keybinding
.IP "ResizeVertical (int)" 4
.IX Item "ResizeVertical (int)"
Resizes a frame vertically. Int is amount of pixels and can be
negative.
.Sp
Moveresize-specific keybinding
.IP "MoveSnap" 4
.IX Item "MoveSnap"
Snaps the frame to the closest frames or screenedges.
.Sp
Moveresize-specific keybinding
.IP "Cancel" 4
.IX Item "Cancel"
Cancels all moveresize actions and keeps the frame how it was before
them.
.Sp
Moveresize-specific keybinding
.IP "End" 4
.IX Item "End"
Aknowledges the moveresize actions and moves/resizes the frame as
wished.
.Sp
Moveresize-specific keybinding
.IP "NextItem" 4
.IX Item "NextItem"
Goes to next menu item.
.Sp
Menu-specific keybinding
.IP "PrevItem" 4
.IX Item "PrevItem"
Goes to previous menu item.
.Sp
Menu-specific keybinding
.IP "Select" 4
.IX Item "Select"
Selects the current menu item.
.Sp
Menu-specific keybinding
.IP "EnterSubmenu" 4
.IX Item "EnterSubmenu"
Enters a submenu.
.Sp
Menu-specific keybinding
.IP "LeaveSubmenu" 4
.IX Item "LeaveSubmenu"
Leaves a submenu.
.Sp
Menu-specific keybinding
.IP "Close" 4
.IX Item "Close"
Closes a menu or a CmdDialog.
.Sp
Menu and CmdDialog-specific keybinding
.IP "Erase" 4
.IX Item "Erase"
Erases the previous character according to the cursor position.
.Sp
CmdDialog-specific keybinding
.IP "Clear" 4
.IX Item "Clear"
Clears the whole CmdDialog line.
.Sp
CmdDialog-specific keybinding
.IP "CursNext" 4
.IX Item "CursNext"
Moves CmdDialog cursor one characer space to right.
.Sp
CmdDialog-specific keybinding
.IP "CursPrev" 4
.IX Item "CursPrev"
Moves CmdDialog cursor one characer space to left.
.Sp
CmdDialog-specific keybinding
.IP "CursBegin" 4
.IX Item "CursBegin"
Moves CmdDialog cursor to the beginning of the line.
.Sp
CmdDialog-specific keybinding
.IP "CursEnd" 4
.IX Item "CursEnd"
Moves CmdDialog cursor to the end of the line.
.Sp
CmdDialog-specific keybinding
.IP "HistPrev" 4
.IX Item "HistPrev"
Bvarlistentryses previously used CmdDialog lines towards the oldest
issued.
.Sp
CmdDialog-specific keybinding
.IP "HistNext" 4
.IX Item "HistNext"
Bvarlistentryses previously used CmdDialog lines towards the newest
issued.
.Sp
CmdDialog-specific keybinding
.IP "Exec" 4
.IX Item "Exec"
Executes the entered line of pekwm actions from CmdDialog. Not to be
confused with the general Exec available everywhere (see above).
.Sp
CmdDialog-specific keybinding
.IP "Insert" 4
.IX Item "Insert"
Allows for the keypress to be inputted to the text field of CmdDialog.
Usually used to allow any other keys than the ones used for CmdDialog
bvarlistentrysing.
.Sp
CmdDialog-specific keybinding
.PP
\&\-\-\-\-
.SH "Chapter 12. The pekwm start file"
.IX Header "Chapter 12. The pekwm start file"
The \f(CW\*(C`~/.pekwm/start\*(C'\fR file is the simplest of all of pekwm's config
files. It's a simple shell script that's run on pekwm startup.
Therefore, to run, it needs to be set executable with \fBchmod +x
~/.pekwm/start\fR.
.PP
Why anyone would use \f(CW\*(C`start\*(C'\fR rather than just use their \f(CW\*(C`~/.xinitrc\*(C'\fR
file? Well, the answer is, the start file is executed during the pekwm
initialization phase\- Therefore, it gets re-executed when you issue a
pekwm 'restart'.
.PP
Here's an example pekwm \f(CW\*(C`start\*(C'\fR file. Be careful to place long running
applications to the background, or you will seem stuck when trying to
start pekwm.
.PP
.Vb 1
\& #!/bin/sh
.Ve
.PP
.Vb 2
\& xmessage 'hi. pekwm started.' &
\& some_command &
.Ve
.PP
\&\-\-\-\-
.SH "Chapter 13. Pekwm themes"
.IX Header "Chapter 13. Pekwm themes"
User installed pekwm themes are historically placed inside
subdirectories in \f(CW\*(C`~/.pekwm/themes/\*(C'\fR. Please use existing themes as
real life examples when it comes to making your own.
.PP
\&\-\-\-\-
.Sh "13.1. Guidelines"
.IX Subsection "13.1. Guidelines"
It is strongly recommended and expected that theme tarballs are labeled
for the pekwm version they are made and tested with. The filename
format should be \f(CW\*(C`theme_name\-pekwm_version.[tar.gz|tgz|tar.bz2|tbz]\*(C'\fR.
For example \f(CW\*(C`silly\-dev\-20050227.tar.bz2\*(C'\fR.
.PP
It is highly recommended and expected that theme directories are named
in a similar fashion. For example, the silly theme above would contain
a directory structure as follows:
.PP
.Vb 4
\& silly-dev-20050227/
\& silly-dev-20050227/theme
\& silly-dev-20050227/menubg.png
\& silly-dev-20050227/submenu.png
.Ve
.PP
\&\s-1NOTE:\s0 if you are making a theme for a pekwm release, lets say 0.1.4, it
is completely ok to only name the tarball with the version number (for
example theme_name\-pekwm014.tar.gz), the directory name doesn't have to
have the version number (as opposed to svn revisions or possible dev
releases.)
.PP
In addition to this, the theme file should contain attleast the
following info in your own free to choose format:
.PP
.Vb 4
\& - the theme name
\& - the pekwm version the theme is for, eg dev-20050227 or 0.1.4
\& - email or website address to reach the theme maker/porter
\& - last modified date
.Ve
.PP
For example:
.PP
.Vb 2
\& # silly, the pekwm-dev theme by shared (themes@adresh.com)
\& # available from hewphoria.com
.Ve
.PP
.Vb 10
\& #
\& # Theme is labeled for pekwm-dev-20050227.
\& #
\& # In short that means it works attleast with the mentioned pekwm
\& # snapshot. Usually it should work fine with newer pekwm-dev releases,
\& # but if you notice it not working after an update, check in for a
\& # new version of the theme.
\& #
\& # Last modified 20050302.
\& #
.Ve
.PP
Preferrably it will also have changelog entries about your changes,
attleast when you are not the original author.
.PP
Try to stick to the theme syntax. If you are not sure if your theme is
made correctly, ask someone who knows.
.PP
Allways use the whole theme structure. Try not to delete or comment out
lines. Use of the \s-1EMPTY\s0 texture to say \*(L"nothing here thanks\*(R" is the
correct way.
.PP
\&\-\-\-\-
.Sh "13.2. Attribute names used, explanations, possible values, examples"
.IX Subsection "13.2. Attribute names used, explanations, possible values, examples"
.Vb 6
\& name            example
\& |               | possible values (if not obvious)
\& |               | | explanation
\& --------------------------------------------------------------------------------------------------
\& "pixels"        "2"
\&                     an integer, amount of pixels
.Ve
.PP
.Vb 2
\& "size"          "2x2"
\&                     pixels vertically times pixels horizontally
.Ve
.PP
.Vb 2
\& "padding"       "2 2 2 2"
\&                     free pixels on top, free pixels under, free pixels to left, free pixels to right
.Ve
.PP
.Vb 14
\& "decorname"     "DEFAULT"
\&                     any name for a decoration set, special decoration set names are:
\&                   DEFAULT,
\&                     defines decorations to all windows unless overridden with another decoration set (REQUIRED!)
\&                   MENU,
\&                     defines decorations for menus
\&                   STATUSWINDOW,
\&                     defines decorations for the status window (REQUIRED!)
\&                   CMDDIALOG,
\&                     defines decorations for the command dialog.
\&                   BORDERLESS,
\&                     defines decorations for borderless wind (RECOMMENDED!)
\&                   TITLEBARLESS,
\&                     defines decorations for titlebarless windows (RECOMMENDED! should be there if your theme looks nasty when titlebarless)
.Ve
.PP
.Vb 2
\& "colour"        "#FFFFFF"
\&                     a colour value in RGB format
.Ve
.PP
.Vb 8
\& "imagename"     "topleftcorner.png#fixed"
\&                     image files filename
\&                   #fixed,
\&                     image is fixed size. Default if omitted.
\&                   #scaled,
\&                     image will be scaled to fit the area it's defined for.
\&                   #tiled,
\&                     image will be repeated as many times as needed to fill the area it's defined for.
.Ve
.PP
.Vb 17
\& "texture"       "Solid #888888 1x1"
\&                     any valid texture. valid textures are:
\&                   EMPTY,
\&                     no texture (transparent)
\&                   SOLID colour size,
\&                     a solid colour texture of defined colour and size
\&                   SOLIDRAISED colour colour colour pixels pixels toggle toggle toggle toggle size,
\&                     a solid colour texture with 3d look of defined colours, form and size. first colour defines
\&                     the main colour, second the top/left borders colour, third the bottom/right borders colour.
\&                     first pixel amount defines how fart apart the 3d effects are from eachother, second pixel
\&                     amount is how thick the bordering will be (both pixels default to 1). The four toggles are
\&                     used to tell which raised corners are to be drawn. This is usefull for example when defining
\&                     solidraised corner pieces. The order is Top, Bottom, Left, Right (order similar to padding).
\&                     So "True False True False" (or 1 0 1 0) could mean you want to draw the TopLeft piece of
\&                     a solidraised window border.
\&                   IMAGE imagename,
\&                     an image texture using the defined imagename
.Ve
.PP
.Vb 3
\& "fontstring"     "Verdana:size=10#Left#1 1#XFT"
\&                     defines a font. first the fontname, then the text orientation, then shadow offsets,
\&                     then font type if not traditional x font. Some fields can be omitted.
.Ve
.PP
.Vb 3
\& "buttonactions"  "1" { Actions = "Close" }
\&                     buttonactions work alike what you are used from the mouse config, first mouse button number
\&                     pressed when this action should happen, then any standard pekwm actions
.Ve
.PP
.Vb 2
\& "cmdstring"      "feh --bg-center myrootimage.png"
\&                     cmdstring is any external command
.Ve
.PP
.Vb 2
\& "percent"        "87"
\&                     any percent value from 1 to 100.
.Ve
.PP
.Vb 2
\& "toggle"         "true"
\&                     sets a value as true (1) or false (0).
.Ve
.PP
\&\-\-\-\-
.Sh "13.3. Structure"
.IX Subsection "13.3. Structure"
\&\s-1PLEASE\s0! Use the \s-1EMPTY\s0 texture to say \*(L"nothing here\*(R" instead of removing
the theme structure.
.PP
.Vb 1
\& PDecor{}: the block for decoration sets, any amount of Decor sections can exist inside this block.
.Ve
.PP
.Vb 1
\&         Decor, decorname{}: name of the decoration set.
.Ve
.PP
.Vb 19
\&                 Title{}: theming of the frame.
\&                         Height, pixels
\&                                 amount of pixels the titlebar should height.
\&                         Pad, padding
\&                                 how many pixels are left around a title text.
\&                         Focused, texture
\&                                 background texture for a focused titlebar.
\&                         UnFocused, texture
\&                                 background texture for an unfocused titlebar.
\&                         WidthMin, pixels
\&                                 minimum width of title in pixels, will also place the titlebar outside of the window borders.
\&                                 use 0 to place titlebar inside borders.
\&                         WidthMax, percent
\&                                 maximum width of titles relative to window width, when this value ends up being smaller than
\&                                 the value in WidthMin, WidthMin is overrided.
\&                         WidthSymetric, toggle
\&                                 set true to constant width titles or false to use titles that only are as big as the clients
\&                                 title text string requires (note, asymmetric width is not fully implemented yet, allways set
\&                                 this true for now).
.Ve
.PP
.Vb 9
\&                         Tab{}: theming of a titlebar tab.
\&                                 Focused, texture
\&                                         background texture for a tab of a focused window.
\&                                 Unfocused, texture
\&                                         background texture for a tab of an unfocused window.
\&                                 FocusedSelected, texture
\&                                         background texture for the currently selected tab of a focused window.
\&                                 UnFocusedSelected, texture
\&                                         background texture for the currently selected tab of an unfocused window.
.Ve
.PP
.Vb 9
\&                         FontColor{}: theming of font colours
\&                                 Focused, colour colour
\&                                         text colour for a tab of a focused window. second value is the shadow colour.
\&                                 Unfocused, colour colour
\&                                         text colour for a tab of an unfocused window. second value for shadow.
\&                                 FocusedSelected, colour colour
\&                                         text colour for the currently selected tab of a focused window. second value for shadow.
\&                                 UnFocusedSelected, colour colour
\&                                         text colour for the currently selected tab of an unfocused window. second value for shadow.
.Ve
.PP
.Vb 9
\&                         Font{}: theming of the titlebar fonts.
\&                                 Focused, fontstring
\&                                         font of the text of a tab of a focused window.
\&                                 Unfocused, fontstring
\&                                         font of the text of a tab of an unfocused window.
\&                                 FocusedSelected, fontstring
\&                                         font of the text of the currently selected tab of a focused window.
\&                                 UnFocusedSelected, fontstring
\&                                         font of the text of the currently selected tab of an unfocused window.
.Ve
.PP
.Vb 5
\&                         Separator{}: theming of the tab separator.
\&                                 Focused, texture
\&                                         separator texture for a focused window.
\&                                 Unfocused, texture
\&                                         separator texture for an unfocused window.
.Ve
.PP
.Vb 11
\&                         Buttons{}: theming of titlebar buttons.
\&                                 Right{}: places the button on the right end of the titlebar.
\&                                 Left{}:  places the button on the left end of the titlebar.
\&                                         Focused, texture
\&                                                 texture for button of a focused window.
\&                                         Unfocused, texture
\&                                                 texture for button of an unfocused window.
\&                                         Pressed, texture
\&                                                 texture for button that is pressed.
\&                                         Button, buttonactions
\&                                                 configures what to do when a button is pressed.
.Ve
.PP
.Vb 19
\&                         Border{}: theming of the borders.
\&                                 Focused{}:   borders for focused windows.
\&                                 UnFocused{}: borders for unfocused windows.
\&                                         TopLeft, texture
\&                                                 texture for the top left corner.
\&                                         Top, texture
\&                                                 texture for the top border.
\&                                         TopRight, texture
\&                                                 texture for the top right corner.
\&                                         Left, texture
\&                                                 texture for the left border.
\&                                         Right, texture
\&                                                 texture for the right birder.
\&                                         BottomLeft, texture
\&                                                 texture for the bottom left corner.
\&                                         Bottom, texture
\&                                                 texture for the bottom border.
\&                                         BottomRight, texture
\&                                                 texture for the bottom right border.
.Ve
.PP
.Vb 3
\& Harbour{}: enables theming of the harbour.
\&         Texture, texture
\&                 texture to use as the background.
.Ve
.PP
.Vb 18
\& Menu{}: themes the insides of a menu window.
\&         Pad, padding
\&                 how many pixels of space around an entry is reserved.
\&         Focused{}:    apply these when the menu/submenu is focused.
\&         Unfocused{}:  apply these when the menu/submenu is not focused.
\&         Selected{}:   apply these on the menu entry currently selected.
\&                 Font, fontstring
\&                         what font to use.
\&                 Background, texture
\&                         a texture that starts from the top of the menu and ends on the bottom.
\&                 Item, texture
\&                         a texture that starts from the top of a menu entry and ends on the bottom of this entry.
\&                 Text, colour
\&                         colour of text.
\&                 Separator, texture
\&                         texture to use as separator. (REQUIRED! way too many themes out there without)
\&                 Arrow, texture
\&                         texture to use for indicating submenus. (REQUIRED! makes menu usage nicer)
.Ve
.PP
.Vb 9
\& CmdDialog{}: themes the insides of a command dialog window.
\&         Font, fontstring
\&                 what font to use.
\&         Texture, texture
\&                 texture to use as the background.
\&         Text, colour
\&                 colour of text.
\&         Pad, padding
\&                 amount of pixels of space around font to reserve.
.Ve
.PP
.Vb 9
\& Status{}: themes the insides of the status window that shows up when moving windows and so on.
\&         Font, fontstring
\&                 what font to use.
\&         Texture, texture
\&                 texture to use as the background.
\&         Text, colour
\&                 colour of text.
\&         Pad, padding
\&                 amount of pixels of space around font to reserve.
.Ve
.PP
.Vb 5
\& Root{}: allows theming the root/background/desktop image.
\&         Command, cmdstring
\&                 takes in an external command to set the background.
\&                 (Will use textures in the future. Note the security risk the current way imposes.
\&                  Never use a theme you haven't checked out.)
.Ve
.SH "IV. Development"
.IX Header "IV. Development"
Interested in pekwm? Want to keep up with the development? Good, we can
tell you how.
.IP "Table of Contents" 4
.IX Item "Table of Contents"
.PD 0
.IP "14. Mailing Lists" 4
.IX Item "14. Mailing Lists"
.IP "15. \s-1IRC\s0" 4
.IX Item "15. IRC"
.IP "16. Bug Tracker" 4
.IX Item "16. Bug Tracker"
.IP "17. The developers" 4
.IX Item "17. The developers"
.PD
.PP
\&\-\-\-\-
.SH "Chapter 14. Mailing Lists"
.IX Header "Chapter 14. Mailing Lists"
The pekwm Mailing lists are used for questions, comments, development
talk and announces. \fIBoth lists are only subscriber postable!\fR You
need to be subscribed to a list before being able to send messages to
it.
.PP
Include your \fBpekwm \-\-info\fR output with your questions and generally
try to be as clear as possible so that everyone understands you.
.PP
\&\-\-\-\-
.Sh "14.1. The Lists"
.IX Subsection "14.1. The Lists"
There are two pekwm mailing lists\- pekwm-devel and pekwm\-users. Which
should you subscribe to? Well, that's for you to decide. Many people
subscribe to both of them.
.PP
pekwm-users is a basic questions mailing list\- \*(L"How do I...\*(R", \*(L"Where do
I...\*(R", \*(L"Check this out!\*(R", and so on. Talk between users is enquoraged,
but advanced users will follow the list for questions, too.
.PP
pekwm-devel is a more discussion-based mailing list\- We discuss where
we're going with development, new features being implemented, current
features. Questions and talk about the development version belong here.
.PP
pekwm-svn is a list that logs pekwm svn commits. Use this list if you
use the svn version of pekwm and want to stay informed on the latest
changes to the codebase.
.PP
\&\-\-\-\-
.Sh "14.2. Mailing list Archives"
.IX Subsection "14.2. Mailing list Archives"
Mailing list archives for the pekwm lists are available for:
pekwm\-users, pekwm-devel and pekwm\-svn.
.PP
\&\-\-\-\-
.Sh "14.3. Subscribing and Filtering"
.IX Subsection "14.3. Subscribing and Filtering"
To subscribe, visit the list info page for pekwm\-users, pekwm-devel or
pekwm\-svn.
.PP
If you'd like to use filters with your mail program, you can check for
mail\-headers. Lists produce a List\-Id: header which will contain the
name of the mailing list (note that there's other information in that
header, though the string 'pekwm\-listname' will be in there).
.PP
\&\-\-\-\-
.SH "Chapter 15. IRC"
.IX Header "Chapter 15. IRC"
Our \s-1IRC\s0 channel is located on irc.freenode.net, in #pekwm. A lot of
devel discussion goes on there, however you can also get simple help
there pretty easily.
.PP
The following is a \*(L"do not\*(R" list. If some idiotic behaviour like,
public away messages, or nick changing as a way of telling what you are
doing, are not mentioned it doesn't mean you can do them.
.PP
As it seems to be a problem for some, do not ask questions in \s-1IRC\s0
unless you are willing to listen to the answer. If listening is your
problem, you need other help than what we at \s-1IRC\s0 can provide.
.PP
If you have a question, ask it. It doesn't help to go around shouting
\&\*(L"can anyone help me\*(R". Help you with what? This will help the right
people to take initial contact with you, saving your time and adding
less clutter to the channel.
.PP
For same reasons, don't ask if we are alive or other meaningles
questions leading to the real question. Don't ask if someone specific
is around eather. This is not the pager channel for you and your
friends.
.PP
Do not ask from one person. The fact is, even how much you think he or
she must be the only one who knows the answer, you are wrong. There's
atleast a handful of people lurking on the channel who could help you.
.PP
Read the documentation and \s-1FAQ\s0 before you ask anything. Doing this is
common courtesy towards the people who answer your questions. Not
reading atleast the \s-1FAQ\s0 will be considered rude.
.PP
When asking a question, the answer more than often depends on the
version of pekwm you use. Showing us the information the command
\&\fBpekwm \-\-info\fR gives will help us help you.
.PP
Do not expect people to answer your questions during the two minutes
you stay in the channel. We can't sit there all the time waiting for
your questions. If you can't wait longer, think about how stresful your
life is, take a break, go on a vacation, take it easy for a while.
.PP
For similar reasons, don't repeat yourself. We saw it the first time.
Repeating easily gets you ignored completely so it eats its own
purpose. It's also considered rude, much like cutting in line.
.PP
If people tell you to read the documentation, they have a good reason
to do so. If they include an \s-1URL\s0 that helps you find the info quicker,
offer them your firstborn as a payback.
.PP
Don't offend anyone. They will offend you back two times.
.PP
Nicks with excessive capital letters will be hunted down and shot on
sight. You might as well use a proper nick to start with to avoid this.
.PP
You can check the developers section to see the list of developers
mapped to their \s-1IRC\s0 nicks.
.PP
As with all \s-1IRC\s0 channels, it's best to not do anything too drastic
before keeping an eye for a while on how the channel works. We won't
mind even if you just idle there, there are long standing traditions on
that.
.PP
Welcome aboard!
.PP
\&\-\-\-\-
.SH "Chapter 16. Bug Tracker"
.IX Header "Chapter 16. Bug Tracker"
Pekwm bug tracker can be reached at pekwm.org. It's based on track, so
bugs are inside tickets. Tickets can be reported and viewed. One can
even include a patch to resolve one.
.PP
Aside from bugs, tickets also eat feature requests.
.PP
\&\-\-\-\-
.SH "Chapter 17. The developers"
.IX Header "Chapter 17. The developers"
Below is a list of pekwm developers and what they do. The email address
is more of an informational thing than anything else; the developers
all subscribe to + pekwm-devel mailing list, so you should email that
instead.
.PP
Developers:
.IP "Claes Na\*:sten (aka pekdon)" 4
.IX Item "Claes Na:sten (aka pekdon)"
\&\f(CW\*(C`<pekdon at pekdon dot net>\*(C'\fR
.Sp
Main developer\- Writes code. Has a serious screenshot fetish.
.IP "Jyri Jokinen (aka shared)" 4
.IX Item "Jyri Jokinen (aka shared)"
\&\f(CW\*(C`<shared@adresh.com>\*(C'\fR
.Sp
Writes documentation. Acts ill\-tempered. You have been warned.
.SH "V. The pekwm FAQ"
.IX Header "V. The pekwm FAQ"
This is the official pekwm \s-1FAQ\s0. Here you can find answers to the
questions and cries for help frequently appearing in the pekwm \s-1IRC\s0
channel and mailing lists.
.PP
If you can't find the answer to your question here, read the whole
thing again. Changes are you just missed it the first time around. If
you still can't find it, and you have gone thru the documentation,
tried until your fingers bleed from typing, and started a hunger strike
against evil documentation projects that contain no helpfull advices
for you, then you may ask your question in \s-1IRC\s0 or one of the mailing
lists.
.IP "Table of Contents" 4
.IX Item "Table of Contents"
.PD 0
.IP "18. Common questions and answers" 4
.IX Item "18. Common questions and answers"
.PD
.PP
\&\-\-\-\-
.SH "Chapter 18. Common questions and answers"
.IX Header "Chapter 18. Common questions and answers"
.Sh "18.1. How is this ~/.pekwm/start thing used?"
.IX Subsection "18.1. How is this ~/.pekwm/start thing used?"
The file \f(CW\*(C`~/.pekwm/start\*(C'\fR is a regular shell script that is executed
when pekwm starts. The file needs to be chmodded as executable (\fBchmod
+x\fR) for it to get used. A simple example start file could look like
this:
.PP
.Vb 3
\& #!/bin/sh
\& gkrellm &
\& Esetroot -s mybackground.png &
.Ve
.PP
Remember the &'s.
.PP
\&\-\-\-\-
.Sh "18.2. What is the harbour?"
.IX Subsection "18.2. What is the harbour?"
Harbour is pekwm's way of supporting dockapps. It's the same as a dock
or a wharf. The harbour is not a \s-1KDE/GNOME\s0 systray for notification
icons. If you want notification icons in the harbour, you need to find
a dockapp that does this for you.
.PP
The harbour is incomplete in features. It has simple functionality and
if it works for you, good. If it doesn't, you are free to share your
code on it.
.PP
\&\-\-\-\-
.Sh "18.3. Why doesn't the harbour work for my dockapp?"
.IX Subsection "18.3. Why doesn't the harbour work for my dockapp?"
The harbour needs to be enabled at compile time. When you are doing the
\&\fB./configure\fR \-phase of the pekwm compile, you can use the
\&\fB\-\-enable\-harbour\fR option to enable it.
.PP
If the dockapp still doesn't go into the harbour, even you have it
enabled at compile time, you should see if the application has an
option to start it \*(L"withdrawn\*(R".
.PP
\&\-\-\-\-
.Sh "18.4. Can I have automatically changing menus in pekwm?"
.IX Subsection "18.4. Can I have automatically changing menus in pekwm?"
Yes. The Dynamic keyword is a way to use automatically generated menus
in pekwm. That is, menus that regenerate every time you view them. As
an example, by default the themes menu is dynamic.
.PP
See Dynamic Menus for more information.
.PP
\&\-\-\-\-
.Sh "18.5. How do I install themes?"
.IX Subsection "18.5. How do I install themes?"
The idea is to unpack/uncompress the theme file you downloaded into
some directory. In this case, we will unpack it to \f(CW\*(C`~/.pekwm/themes\*(C'\fR,
which is the standard location for user installed themes.
.PP
In simple, first make sure the themes directory exist, and if not, make
it by issuing the command \fBmkdir ~/.pekwm/themes\fR.
.PP
Then copy the theme package, lets call it theme.tar.gz, into
\&\f(CW\*(C`~/.pekwm/themes\*(C'\fR. Then uncompress the theme pack with the appropriate
tool. Unpack the theme with: \fBgzip \-dc theme.tar.gz | tar xvf \-\fR
.PP
You will then end up with a new subdirectory \- this is the theme.
.PP
Since we uncompressed the theme in a standard location, after this you
can select the new theme from the themes menu. If you installed in a
non-standard location, you'll have to manually edit \f(CW\*(C`~/.pekwm/config\*(C'\fR.
In the top of this file there is a section named \*(L"Files {}\*(R". In this
section, there is a line that says something like:
.PP
.Vb 1
\& Theme = "/usr/local/share/pekwm/themes/minimal"
.Ve
.PP
Edit this line to point to the directory you installed the theme.
Restart pekwm and you're set.
.PP
\&\-\-\-\-
.Sh "18.6. I upgraded pekwm and now ......... won't work!"
.IX Subsection "18.6. I upgraded pekwm and now ......... won't work!"
Pekwm has not yet achieved a freeze on it's configuration file syntax.
And as pekwm is an actively developed application, there probably have
been some changes on some part of the configuration.
.PP
If you encounter a situation that when you upgrade your pekwm, and some
thing just stops to work, you should either:
.PP
\&\fIMove your old configuration out of the way\fR \- Move your pekwm
configuration files out of \f(CW\*(C`~/.pekwm\*(C'\fR ( \fBmv ~/.pekwm ~/old.pekwm\fR),
which will result in new fresh configuration files being copied in. If
this helps, your configuration files werent compatible with the new
version of pekwm.
.PP
\&\fICheck the ChangeLog\fR \- If something configurable wise has been
changed, it has also been documented in the \f(CW\*(C`ChangeLog\*(C'\fR. This is a
helpfull resource when you want to convert your old configuration files
to a newer configuration format.
.PP
\&\fILook under the source trees \f(CI\*(C`data/\*(C'\fI directory for reference\fR \- If
you can't find info about a new feature or for some reason you don't
understand the brief explanation in the \f(CW\*(C`ChangeLog\*(C'\fR, there is a
\&\f(CW\*(C`data/\*(C'\fR directory in the source package of pekwm that has example
configuration files (that act as the default configs on a new install).
Chances are you'll find help from there.
.PP
\&\fIRead the documentation.\fR \- You can find links to up to date
documentation for your pekwm version at the pekwm homepage.
.PP
\&\fIMake sure the right executable is being executed.\fR \- Locate all
instances of pekwm (\fBfind / \-name 'pekwm'\fR). If you see many pekwm
executables laying around, maybe one in \f(CW\*(C`/usr/bin\*(C'\fR and one in
\&\f(CW\*(C`/usr/local/bin\*(C'\fR, you might be starting a wrong version pekwm. This
might happen when you for example, install a premade pekwm package for
your distribution and later install pekwm from source yourself. The
safe way is to remove all these pekwm instances and either re-apply the
package or do \fBmake install\fR again in the source. You can also, of
course, go thru every pekwm binary with the \-\-version parameter to find
the right executable to keep. Note to give the full path to the
executable when querying for the version (\fB/usr/local/bin/pekwm
\&\-\-version\fR).
.PP
\&\-\-\-\-
.Sh "18.7. Can I turn off this sloppy focus crap?"
.IX Subsection "18.7. Can I turn off this sloppy focus crap?"
Yes. You can. You need to make all enter and leave events not affect
the focus of frames, borders, clients. Simply, just comment out all the
Enter lines that use the action Focus in \f(CW\*(C`~/.pekwm/mouse\*(C'\fR.
.PP
The default \f(CW\*(C`~/.pekwm/mouse\*(C'\fR configuration file has helpfull \*(L"# Remove
the following line if you want to use click to focus.\*(R" notes in it to
make this easier. Just search for such lines and remove or comment out
the line (using a # in front of the line) next to the message.
.PP
See Mouse Bindings for more info on the mouse configuration file.
.PP
\&\-\-\-\-
.Sh "18.8. What is Mod1? How about Mod4?"
.IX Subsection "18.8. What is Mod1? How about Mod4?"
In the \f(CW\*(C`~/.pekwm/keys\*(C'\fR and \f(CW\*(C`~/.pekwm/mouse\*(C'\fR there are all these odd
Mod1 and Mod4 things used as modifier keys. It's simple \- Mod1 is more
widely known as the Alt key, and Mod4 as the \*(L"windows key\*(R" found on
recent keyboards. Use \fBxev\fR to find out what names keys carry.
.PP
\&\-\-\-\-
.Sh "18.9. Why do my terminals start the wrong size when grouped?"
.IX Subsection "18.9. Why do my terminals start the wrong size when grouped?"
This is a very complicated issue in fact, and has to do with the way
terminals handle their resize actions. One way to bring at least some
help to this situation is to put \fBresize > /dev/null\fR in your
\&.bashrc or equal.
.PP
\&\-\-\-\-
.Sh "18.10. Where can I find the current size/position of a window?"
.IX Subsection "18.10. Where can I find the current size/position of a window?"
Use the command \fBxwininfo | grep geometry\fR.
.PP
\&\-\-\-\-
.Sh "18.11. How do I bring up the window menu when the window has no decorations?"
.IX Subsection "18.11. How do I bring up the window menu when the window has no decorations?"
You press keys. The default keybinding for window menu is at the moment
first Ctrl+Mod1+M, then W (or Mod4+W for short). You can specify your
own keybinding for window menu at the \f(CW\*(C`~/.pekwm/keys\*(C'\fR configuration
file. See Key Bindings for information on how to edit keybindings.
.PP
\&\-\-\-\-
.Sh "18.12. When I xprop a grouped window, it gives the results of wrong window!"
.IX Subsection "18.12. When I xprop a grouped window, it gives the results of wrong window!"
Yep. We know. Actually, there already exist a patch that makes it work
at bugs.xfree86.org. In short, it's a X\-issue \- go whine at your
favourite X developers.
.PP
\&\-\-\-\-
.Sh "18.13. The start file doesn't work!"
.IX Subsection "18.13. The start file doesn't work!"
\&\fBchmod +x ~/.pekwm/start\fR. Yes, this is a duplicate of the first \s-1FAQ\s0
entry. Just making sure we never have to see this question in \s-1IRC\s0
anymore. So if you asked this question and was directed here, remorse.
.PP
\&\-\-\-\-
.Sh "18.14. How do I set a background/root/desktop image?"
.IX Subsection "18.14. How do I set a background/root/desktop image?"
In simple terms, you use any program that is capaple of setting
background images. What? Want links too? Because you asked nice, here's
feh and hsetroot. If you have Eterm installed you have a program named
Esetroot, that will set you backgrounds. There's a million of similar
apps, and this is no place for a comprehensive list of them.
.PP
You want that the background gets set automatically when you start
pekwm? You have three options. Eather, add the command that you use to
set your background into \f(CW\*(C`~/.xinitrc\*(C'\fR (or similar) before the command
that starts pekwm. Or, add the command to set a background in to your
pekwm \f(CW\*(C`start\*(C'\fR file located at \f(CW\*(C`~/.pekwm/start\*(C'\fR. Or, edit the right
place in your pekwm theme file to include the command to set a
background with.
.PP
\&\-\-\-\-
.Sh "18.15. A theme I tested doesn't work!"
.IX Subsection "18.15. A theme I tested doesn't work!"
Pekwm is an ongoing process. This means the theme file format has gone
thru considerable amounts of changes. Some of these changes are
backwards compatible, some are not. You have hit a theme with too old
or too new theme syntax for your copy of pekwm. Nothing can be done
unless someone who knows the differences between theme formats owns you
a favor and agrees to edit it out for you.
.PP
Pekwm shouldn't refuse to start again after a faulting theme test, but
you will usually see everything scrambled up. In this case you can
eather try to select a new working theme from the menu or change the
theme used manually. This is done in \f(CW\*(C`~/.pekwm/config\*(C'\fR. Under the
Files\-section, there is an entry named Theme, that points to your
current theme. It might look something like this:
.PP
.Vb 3
\& Files {
\&         Theme = "/home/shared/.pekwm/themes/blopsus9-blaah"
\& }
.Ve
.PP
Now, all you need to do is make the path point to any theme you know is
working. The default theme is usually a safe bet. After edited and
saved, (re)start pekwm.
.PP
\&\-\-\-\-
.Sh "18.16. PekWM just dumps core, FreeBSD."
.IX Subsection "18.16. PekWM just dumps core, FreeBSD."
On newer FreeBSD versions (newer than 5.3, especially
6.0\-Current\-series) pekwm cannot be started:
.PP
.Vb 1
\&Nov 20 17:59:07 **** kernel: pid 8423 (pekwm), uid 1010: exited on signal 10 (core dumped)
.Ve
.PP
There is a workaround for this problem. Type \fBln \-s aj
/etc/malloc.conf\fR as root to disable memory debugging.
.PP
\&\-\-\-\-
.Sh "18.17. What desktop pagers work with pekwm?"
.IX Subsection "18.17. What desktop pagers work with pekwm?"
For general use any \s-1NETWM\s0 compliant pager should do. IPager, rox\-pager,
fbpanel's pager, obpager, gai\-pager, gnome's pager, kde's pager,
perlpanel's pager, netwmpager, and so on. Gai-pager is one of the few
that actually work with viewports. Do report your success stories with
pagers not already mentioned here.
.PP
\&\-\-\-\-
.Sh "18.18. How do I make submenus open on mouse over rather than when clicked?"
.IX Subsection "18.18. How do I make submenus open on mouse over rather than when clicked?"
You need to edit \f(CW\*(C`~/.pekwm/config\*(C'\fR. Open it in an editor and search
for the Menu section towards the end of the file. It should look
somewhat like this:
.PP
.Vb 5
\& Menu {
\&         # Defines how menus act on mouse input.
\&         # Possible values are: "ButtonPress ButtonRelease DoubleClick Motion"
\&         # To make submenus open on mouse over, comment the default Enter,
\&         # uncomment the alternative, and reload pekwm.
.Ve
.PP
.Vb 5
\&         Select = "Motion"
\&         Enter = "ButtonPress"
\&         # Enter = "Motion"
\&         Exec = "ButtonRelease"
\& }
.Ve
.PP
To make submenus open on mouse over, remove or comment out the line
.PP
.Vb 1
\&       Enter = "ButtonPress"
.Ve
.PP
and remove the # character from this line:
.PP
.Vb 1
\&       # Enter = "Motion"
.Ve
.PP
so that it looks like this:
.PP
.Vb 1
\&       Enter = "Motion"
.Ve
.PP
and you should be fine. Reload pekwm configuration from the menu or
press ctrl+mod1+delete to do it with a keybinding. Test your
semiautomatic pekwm menus!
.PP
The default requires you to click because of dynamic menus. While
reasonably fast, they can sometimes take a second or two to be
generated depending on the script behind it. Browsing the menu tree can
at such times become more annoying, specially on a slower machine, than
having to do that extra click. There you have it, our reasoning and the
solution for if you don't like it.
